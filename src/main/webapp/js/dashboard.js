// Generated by CoffeeScript 1.4.0

/*
An asynchronous request to the server.
The request is automatically encoded and decoded with base64 to avoid strange errors.

param requestType       # The identifier with which the server identifiers the correct handler
param requestBody       # An object which will be sent to the server in the body of the request (e.g. the notaql-script)
param options
  url                   # To specify a url for the request
*/


(function() {
  var ConfigurationWindow, Console, ConsoleContent, ConsoleWindow, Content, Engine, EngineContent, EngineWindow, KeyValueContent, Line, LoadContent, LoadWindow, Main, MessagePoller, NotaqlExecution, Server, ServerEngine, ServerRequest, StoreContent, StoreWindow, SwitchableContent, Transformation, TransformationContent, TransformationWindow, Window, main,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ServerRequest = (function() {

    ServerRequest.DEFAULT_URL = REQUEST_URL;

    ServerRequest.REQUEST_TYPE_GET_ENGINES = "get_all_engines";

    ServerRequest.REQUEST_TYPE_TRANSFORMATION_PROCESSOR = "transformation_processor";

    ServerRequest.REQUEST_TYPE_CONFIGURATION_GET = "get_configuration";

    ServerRequest.REQUEST_TYPE_CONFIGURATION_SET = "set_configuration";

    ServerRequest.REQUEST_TYPE_KILL_ALL = "kill_all";

    ServerRequest.REQUEST_TYPE_KILL = "kill";

    ServerRequest.REQUEST_TYPE_TRANSFORMATION_STORE = "transformation_store";

    ServerRequest.REQUEST_TYPE_TRANSFORMATION_LOAD = "transformation_load";

    ServerRequest.DATAURI_JSON = "data:application/json;base64,";

    function ServerRequest(type, body, options) {
      this.type = type;
      this.body = body != null ? body : {};
      this.options = options != null ? options : {};
      if (this.options.url == null) {
        this.options.url = ServerRequest.DEFAULT_URL;
      }
      this.requestObject = {
        request_type: this.type,
        request: this.body
      };
      this.requestObjectString = encodeURIComponent($.base64.btoa(JSON.stringify(this.requestObject), true));
      this.request = $.ajax({
        url: this.options.url,
        method: "POST",
        data: "jsonBase64=" + this.requestObjectString
      });
    }

    /*
      Adds a function to the request which will be executed after completion.
      The functions will be executed even if the request fails.
    
      This function will decode the received base64 and also will try to convert the response into a java-object.
      If the conversion fails the text of the response will be passed to func
    
      param func The function to call with the response (or null) as parameter.
    */


    ServerRequest.prototype.addDoneFunction = function(func) {
      return this.request.always(function(response) {
        var decodedResponse;
        decodedResponse = null;
        if (response.responseText != null) {
          decodedResponse = decodeURIComponent(response.responseText);
          if ((decodedResponse.lastIndexOf(ServerRequest.DATAURI_JSON, 0)) === 0) {
            try {
              decodedResponse = $.base64.atob(decodedResponse.substring(ServerRequest.DATAURI_JSON.length), true);
            } catch (error) {
              Main.console.debug("JS-Fehler 64 @ ServerRequest.addDoneFunction(): " + error);
            }
            try {
              decodedResponse = JSON.parse(decodedResponse);
              if ((decodedResponse.response != null) && decodedResponse.response !== "ok") {
                Main.console.debug(JSON.stringify(decodedResponse, null, 1));
              }
            } catch (error) {
              Main.console.debug("JS-Fehler 72 @ ServerRequest.addDoneFunction(): '" + error + "' for '" + decodedResponse + "'");
            }
          }
        }
        return func(decodedResponse);
      });
    };

    return ServerRequest;

  })();

  /*
  The message poller. Retrieves messages from the server.
  
  param options =
    pollingIntervallMillis    # The Intervall between polling-attemps from the server in milliseconds
  */


  MessagePoller = (function() {

    MessagePoller.DEFAULT_POLLING_INTERVALL_MILLIS = 10000;

    MessagePoller.MESSAGE_TYPE_CONSOLE_APPEND = "console_append";

    function MessagePoller(options) {
      this.options = options != null ? options : {};
      if (this.options.pollingIntervallMillis == null) {
        this.options.pollingIntervallMillis = MessagePoller.DEFAULT_POLLING_INTERVALL_MILLIS;
      }
      this.run();
    }

    /*
      Polls the server, waits some time and then calls itself again.
    */


    MessagePoller.prototype.run = function() {
      var _this = this;
      this.poll();
      return setTimeout(function() {
        return _this.run();
      }, this.options.pollingIntervallMillis);
    };

    /*
      Polls the messages from the server
    */


    MessagePoller.prototype.poll = function() {
      var pollingRequest,
        _this = this;
      pollingRequest = new ServerRequest(MessagePoller.MESSAGE_TYPE_CONSOLE_APPEND, null, {
        url: POLLING_URL
      });
      return pollingRequest.addDoneFunction(function(returnJson) {
        return _this.processResponse(returnJson);
      });
    };

    /*
      Processes the response-json from the server
    
      param returnJson
    */


    MessagePoller.prototype.processResponse = function(returnJson) {
      var message, _i, _len, _ref, _results;
      if ((returnJson != null ? returnJson.messages : void 0) != null) {
        _ref = returnJson.messages;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          message = _ref[_i];
          switch (message.message_type) {
            case MessagePoller.MESSAGE_TYPE_CONSOLE_APPEND:
              _results.push(this.processConsoleAppend(message));
              break;
            default:
              _results.push(alert("Invalid Message received from the server " + (JSON.stringify(message))));
          }
        }
        return _results;
      }
    };

    /*
      Processes a message which is supposed to be shown in the consle
    */


    MessagePoller.prototype.processConsoleAppend = function(messageObject) {
      if (Main.console) {
        return Main.console.print(messageObject.text);
      }
    };

    return MessagePoller;

  })();

  /*
  Wraps the execution of a notaql-script.
  
  param transformation    # The notaql-transformation
  param options =
    callbackFunction      # The function which will be executed after the execution finishes
    forecast              # If the user wants just a forecast of the runtime
    advisor               # If the user wants the system to take control about the execution mode
    resetAdvisor          # To reset the advisor used for "automated"
  */


  NotaqlExecution = (function() {

    function NotaqlExecution(transformation, options) {
      this.transformation = transformation;
      this.options = options != null ? options : {};
      if (!this.options.callbackFunction) {
        this.options.callbackFunction = function() {};
      }
      if (this.options.forecast == null) {
        this.options.forecast = false;
      }
      if (this.options.resetAdvisor == null) {
        this.options.resetAdvisor = false;
      }
      if (this.options.advisor == null) {
        this.options.advisor = false;
      }
      this.execute();
    }

    /*
      Executes the script
    
      param callbackFunction is executed after the execution finishes
    */


    NotaqlExecution.prototype.execute = function() {
      var requestBody,
        _this = this;
      requestBody = this.transformation.serialize();
      if (this.options.forecast) {
        requestBody.forecast = true;
      }
      if (this.options.advisor) {
        requestBody.advisor = true;
      }
      if (this.options.resetAdvisor) {
        requestBody.resetAdvisor = true;
      }
      this.request = new ServerRequest(ServerRequest.REQUEST_TYPE_TRANSFORMATION_PROCESSOR, requestBody);
      return this.request.addDoneFunction(function(returnJson) {
        return _this.options.callbackFunction(returnJson);
      });
    };

    return NotaqlExecution;

  })();

  /*
  Wraps informations about a specific engine at the server
  
  param typeName    # The name of the engine (e.g. "csv")
  param arguments   # The arguments for the engine (e.g. "csv_path")
  */


  ServerEngine = (function() {

    function ServerEngine(typeName, _arguments, requiredArguments, advisorArguments) {
      this.typeName = typeName;
      this["arguments"] = _arguments;
      this.requiredArguments = requiredArguments != null ? requiredArguments : [];
      this.advisorArguments = advisorArguments != null ? advisorArguments : [];
    }

    /*
      Creates a ServerEngine-instance based on the json which is delivered by the server
    
      param json server-response
    */


    ServerEngine.createFromServerJson = function(json) {
      return new ServerEngine(json.typeName, json["arguments"], json.requiredArguments, json.advisorArguments);
    };

    /*
      Checks if the given argument is required
    
      param argument a string
    */


    ServerEngine.prototype.isArgumentRequired = function(argument) {
      if (__indexOf.call(this.requiredArguments, argument) >= 0) {
        return true;
      } else {
        return false;
      }
    };

    return ServerEngine;

  })();

  /*
  Wraps informations about the server (e.g. available engines)
  
  param options
  */


  Server = (function() {

    function Server() {}

    /*
      Gets the available engines
    
      return [ServerEngine]
    */


    Server.prototype.getEngines = function() {
      if (this.engines != null) {
        return this.engines;
      } else {
        return [];
      }
    };

    /*
      Gets the specified engine by its type (=name)
    
      return ServerEngine or null
    */


    Server.prototype.getEngine = function(typeName) {
      var engine, _i, _len, _ref;
      _ref = this.getEngines();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        engine = _ref[_i];
        if (engine.typeName === typeName) {
          return engine;
        }
      }
      return null;
    };

    /*
      Stores available engines
    
      param serverEngines [ServerEngine]
    */


    Server.prototype.setEngines = function(serverEngines) {
      return this.engines = serverEngines;
    };

    return Server;

  })();

  /*
  Wraps the content to be displayed inside a Window
  
  param window    # The window which belongs to this content
  param options
    html          # The html to be used for the content
  */


  Content = (function() {

    Content.DEFAULT_HTML = "";

    function Content(window, options) {
      this.window = window;
      this.options = options != null ? options : {};
      this.create();
    }

    /*
      Creates the nodeContent
    */


    Content.prototype.create = function() {
      if (this.options.html != null) {
        return this.nodeContent = $(this.options.html);
      } else {
        return this.nodeContent = $(Content.DEFAULT_HTML);
      }
    };

    return Content;

  })();

  /*
  Wraps the content to be displayed inside a ConsoleWindow
  
  param window                    # The window which belongs to this content
  param options =
    windowAutoscroll              # Whether the window should automatically scroll down after appending text to it
  */


  ConsoleContent = (function(_super) {

    __extends(ConsoleContent, _super);

    ConsoleContent.DEFAULT_WINDOW_AUTOSCROLL = true;

    function ConsoleContent(window, options) {
      this.window = window;
      this.options = options != null ? options : {};
      if (this.options.windowAutoscroll == null) {
        this.options.windowAutoscroll = ConsoleContent.DEFAULT_WINDOW_AUTOSCROLL;
      }
      ConsoleContent.__super__.constructor.call(this, this.window, this.options);
    }

    /*
      Creates the initial nodeContent (the selection for the engine-type)
    
      Overrides the function from super()
    */


    ConsoleContent.prototype.create = function() {
      return this.nodeContent = $("<textarea class='grow transparent' readonly='1'></textarea>");
    };

    /*
      Appends a text to the textarea
    
      param text
    */


    ConsoleContent.prototype.append = function(text) {
      if (text == null) {
        text = "";
      }
      this.nodeContent.val(this.nodeContent.val() + text + "\n");
      if (this.options.windowAutoscroll) {
        return this.scrollDown();
      }
    };

    /*
      Scrolls down the textarea to the end of the text
    */


    ConsoleContent.prototype.scrollDown = function() {
      return this.nodeContent.scrollTop(this.nodeContent[0].scrollHeight - this.nodeContent.height());
    };

    /*
      Clears the content
    */


    ConsoleContent.prototype.clear = function() {
      this.nodeContent.val("");
      return this.append("Konsole geleert");
    };

    return ConsoleContent;

  })(Content);

  /*
  Wraps the content to be displayed inside a EngineWindow
  
  param engine                    # The EngineWindow which belongs to this content
  param options =
    server                        # Contains informations from the server
    {arguments}                   # The initial arguments of the server (e.g. "csv_path")
  */


  EngineContent = (function(_super) {

    __extends(EngineContent, _super);

    function EngineContent(engine, options) {
      var argument, value, _ref;
      this.engine = engine;
      this.options = options != null ? options : {};
      EngineContent.__super__.constructor.call(this, this.engine, this.options);
      if (this.engine.type != null) {
        this.eventEngineTypeChanged();
        if (this.options["arguments"] != null) {
          _ref = this.options["arguments"];
          for (argument in _ref) {
            value = _ref[argument];
            try {
              if (argument.substr(0, 8) === "boolean_") {
                this.engineSpecificArguments[argument].prop("indeterminate", false);
                this.engineSpecificArguments[argument].prop("checked", value);
              } else {
                this.engineSpecificArguments[argument].val(value);
              }
            } catch (error) {
              Main.console.error("Kann Parameter '" + argument + "' nicht setzen (" + error + ")");
            }
          }
        }
      }
    }

    /*
      Creates the initial nodeContent (the selection for the engine-type)
    
      Overrides the function from super()
    */


    EngineContent.prototype.create = function() {
      var engine, isEngineSelected, nodeEngine, _i, _len, _ref,
        _this = this;
      this.nodeContent = $("<div></div>");
      this.nodeForm = $("<form action='#'></form>");
      this.nodeSelectEngineType = $("<select name='engine_typename' class='engineselection'></select>");
      this.nodeFieldsetEngineGeneric = $("<fieldset><legend>Engine</legend></fieldset>");
      this.nodeFieldsetEngineSpecific = $("<fieldset class='enginespecific'></fieldset>");
      this.nodeFieldsetEngineGeneric.append(this.nodeSelectEngineType);
      this.nodeForm.append(this.nodeFieldsetEngineGeneric);
      this.nodeContent.append(this.nodeForm);
      this.nodeSelectEngineType.append($("<option value=''" + (this.engine.type == null ? ' selected' : '') + " disabled>Bitte ausw&auml;hlen</option>"));
      _ref = this.options.server.getEngines();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        engine = _ref[_i];
        isEngineSelected = (this.engine.type != null) && engine === this.engine.type;
        nodeEngine = $("<option value='" + engine.typeName + "'" + (isEngineSelected ? ' selected' : '') + ">" + engine.typeName + "</option>");
        this.nodeSelectEngineType.append(nodeEngine);
      }
      return this.nodeSelectEngineType.change(function() {
        return _this.eventEngineTypeChanged();
      });
    };

    /*
      Triggered when any engine was selected (maybe even the same as it is at the moment)
    */


    EngineContent.prototype.eventEngineTypeChanged = function() {
      var selectedEngine;
      selectedEngine = this.options.server.getEngine(this.nodeSelectEngineType.val());
      if (!(this.engineSpecificArguments != null) || this.engine.type !== selectedEngine) {
        this.engine.type = selectedEngine;
        this.updateContent();
        return this.engine.eventEngineTypeChanged();
      }
    };

    /*
      Triggered when an engine argument was changed
    */


    EngineContent.prototype.eventEngineArgumentChanged = function() {
      return this.engine.eventEngineArgumentChanged();
    };

    /*
      Triggered when a *boolean* engine argument was changed
    
      Ensures that the indeterminate state is still available after a click.
    
      param event the event data
    */


    EngineContent.prototype.eventBooleanEngineArgumentChanged = function(event) {
      var nodeInput;
      nodeInput = $(event.target);
      switch (nodeInput.data("checked")) {
        case 0:
          nodeInput.data("checked", 1);
          nodeInput.prop("indeterminate", true);
          break;
        case 1:
          nodeInput.data("checked", 2);
          nodeInput.prop("indeterminate", false);
          nodeInput.prop("checked", true);
          break;
        default:
          nodeInput.data("checked", 0);
          nodeInput.prop("indeterminate", false);
          nodeInput.prop("checked", false);
      }
      return this.eventEngineArgumentChanged();
    };

    /*
      Updates engine-specific stuff in the content.
    
      Called by Engine -> EngineWindow -> EngineContent
    */


    EngineContent.prototype.updateContent = function() {
      var argument, inputPlaceholder, _i, _len, _ref,
        _this = this;
      if (this.nodeForm.find("fieldset.enginespecific").length && this.engine.type["arguments"].length === 0) {
        this.nodeForm.remove(this.nodeFieldsetEngineSpecific);
      } else if (!this.nodeForm.find("fieldset.enginespecific").length) {
        this.nodeForm.append(this.nodeFieldsetEngineSpecific);
      } else {
        this.nodeFieldsetEngineSpecific.empty();
      }
      this.nodeFieldsetEngineSpecific.append($("<legend>" + this.engine.type.typeName + "</legend>"));
      this.engineSpecificArguments = {};
      _ref = this.engine.type["arguments"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        argument = _ref[_i];
        inputPlaceholder = "" + argument + (this.engine.type.isArgumentRequired(argument) ? ' (*)' : '');
        if (argument.substr(0, 8) === "boolean_") {
          this.engineSpecificArguments[argument] = $("<input type='checkbox' name='" + argument + "' value='" + argument + "'>");
          this.engineSpecificArguments[argument].data("checked", 1);
          this.engineSpecificArguments[argument].prop("indeterminate", true);
          this.nodeFieldsetEngineSpecific.append($("<div class='inputcontainer'></div>").append($("<label></label>").append(this.engineSpecificArguments[argument], "<span class='text'>" + (inputPlaceholder.substr(8, inputPlaceholder.length)) + "</span>")));
          this.engineSpecificArguments[argument].on("change", function(event) {
            return _this.eventBooleanEngineArgumentChanged(event);
          });
        } else {
          this.engineSpecificArguments[argument] = $("<input type='text' name='" + argument + "' placeholder='" + inputPlaceholder + "' class='engineparameter'>");
          this.nodeFieldsetEngineSpecific.append($("<div class='inputcontainer'></div>").append(this.engineSpecificArguments[argument]));
          this.engineSpecificArguments[argument].bind("input", function() {
            return _this.eventEngineArgumentChanged();
          });
        }
      }
      return this.engine.eventContentChanged();
    };

    /*
      Triggered when the attached transformation is set to automated.
    
      Sets nearly everything to readonly
    
      param newState
    */


    EngineContent.prototype.eventSetAutomated = function(newState) {
      var argument, nodeInput, _ref;
      _ref = this.engineSpecificArguments;
      for (argument in _ref) {
        nodeInput = _ref[argument];
        if (__indexOf.call(this.engine.type.advisorArguments, argument) < 0) {
          nodeInput.attr("readonly", newState);
        }
      }
      return this.nodeSelectEngineType.attr("disabled", newState);
    };

    return EngineContent;

  })(Content);

  /*
  Content on a key-value basis
  
  param window                    # The window which belongs to this content
  param options
  */


  KeyValueContent = (function(_super) {

    __extends(KeyValueContent, _super);

    function KeyValueContent(window, options) {
      this.window = window;
      this.options = options != null ? options : {};
      KeyValueContent.__super__.constructor.call(this, this.window, this.options);
    }

    /*
      Creates the initial nodeContent (the selection for the engine-type)
    
      Overrides the function from super()
    */


    KeyValueContent.prototype.create = function() {
      var _this = this;
      this.nodeContent = $("<div class='content'></div>");
      this.nodeFieldsetOptions = $("<fieldset><legend>Aktionen</legend></fieldset>");
      this.nodeButtonStore = $("<button type='button'>Speichern</button>");
      this.nodeButtonReload = $("<button type='button'>Neu laden</button>");
      this.nodeFieldsetKeyValue = $("<fieldset><legend>Daten</legend></fieldset>");
      this.nodeFieldsetKeyValueTable = $("<table style='border:none;'></table>");
      this.nodeContent.append(this.nodeFieldsetOptions);
      this.nodeFieldsetOptions.append(this.nodeButtonStore);
      this.nodeFieldsetOptions.append(this.nodeButtonReload);
      this.nodeContent.append(this.nodeFieldsetKeyValue);
      this.nodeFieldsetKeyValue.append(this.nodeFieldsetKeyValueTable);
      this.createKeyValueInputs();
      this.nodeButtonStore.click(function() {
        return _this.eventButtonPressedStore();
      });
      return this.nodeButtonReload.click(function() {
        return _this.eventButtonPressedLoad();
      });
    };

    /*
      Clears all key-value rows from the content
    
      This is a workaround - it didn't seem to work in another way
    */


    KeyValueContent.prototype.clearKeyValues = function() {
      var element, _i, _len, _ref;
      _ref = this.nodeFieldsetKeyValue.children();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        element.remove();
      }
      return this.inputs = {};
    };

    /*
      Reloads the key-values from the window and ats them to the content.
    */


    KeyValueContent.prototype.createKeyValueInputs = function() {
      var inputcontainer, key, value, _ref, _results;
      this.inputs = {};
      _ref = this.window.getKeyValues();
      _results = [];
      for (key in _ref) {
        value = _ref[key];
        this.inputs[key] = $("<input type='text' name='" + key + "' placeholder='" + key + "' value='" + value + "'>");
        inputcontainer = $("<tr></tr>");
        inputcontainer.append($("<td><label for='" + key + "'>" + key + "</label></td>"));
        inputcontainer.append($("<td></td>").append(this.inputs[key]));
        _results.push(this.nodeFieldsetKeyValue.append(inputcontainer));
      }
      return _results;
    };

    /*
      Triggered when the user wants to load the data
    */


    KeyValueContent.prototype.eventButtonPressedLoad = function() {
      var _this = this;
      this.clearKeyValues();
      return setTimeout(function() {
        return _this.window.requestKeyValues();
      }, 50);
    };

    /*
      Triggered when the user wants to store the data
    */


    KeyValueContent.prototype.eventButtonPressedStore = function() {
      var input, key, keyValues, _ref;
      if (!(this.inputs != null)) {
        return this.window.setKeyValues({});
      } else {
        keyValues = {};
        _ref = this.inputs;
        for (key in _ref) {
          input = _ref[key];
          keyValues[key] = input.val();
        }
        return this.window.setKeyValues(keyValues);
      }
    };

    return KeyValueContent;

  })(Content);

  /*
  Base class for Contents which have differnt views to display the data (e.g. StoreContent or LoadContent)
  
  param window          # The window which belongs to this content
  param views           # The views which may be displayed (e.g. base64 and json)
  param options
    readonly            # Whether or not the textarea shall be readonly
  */


  SwitchableContent = (function(_super) {

    __extends(SwitchableContent, _super);

    SwitchableContent.DEFAULT_READONLY = true;

    SwitchableContent.DEFAULT_VIEWS = {
      "default": "Standard"
    };

    function SwitchableContent(window, views, options) {
      this.window = window;
      this.views = views != null ? views : SwitchableContent.DEFAULT_VIEWS;
      this.options = options != null ? options : {};
      if (this.options.readonly == null) {
        this.options.readonly = SwitchableContent.DEFAULT_READONLY;
      }
      this.previousView = null;
      this.currentView = null;
      SwitchableContent.__super__.constructor.call(this, this.window, this.options);
    }

    /*
      Creates the initial nodeContent (the selection for the engine-type)
    
      Overrides the function from super()
    */


    SwitchableContent.prototype.create = function() {
      var isFirst, key, value, _ref,
        _this = this;
      this.nodeContent = $("<div class='content'></div>");
      this.nodeFieldsetOptions = $("<fieldset><legend>Optionen</legend></fieldset>");
      this.nodeSelectView = $("<select></select>");
      this.nodeData = $("<textarea class='grow'" + (this.options.readonly ? ' readonly=\'1\'' : '') + ">" + (this.getInitialData()) + "</textarea>");
      isFirst = true;
      _ref = this.views;
      for (key in _ref) {
        value = _ref[key];
        this.nodeSelectView.append($("<option value='" + value + "'" + (isFirst ? ' selected' : '') + ">" + value + "</option>"));
        if (isFirst) {
          this.currentView = value;
          isFirst = false;
        }
      }
      this.nodeContent.append(this.nodeFieldsetOptions);
      this.nodeFieldsetOptions.append(this.nodeSelectView);
      this.nodeContent.append(this.nodeData);
      return this.nodeSelectView.change(function() {
        return _this.eventSelectedViewChanged();
      });
    };

    /*
      Returns the initial data to be displayed
    */


    SwitchableContent.prototype.getInitialData = function() {
      return "";
    };

    /*
      Updates the state of the view-variables
    */


    SwitchableContent.prototype.updateVariables = function() {
      var newView;
      newView = this.nodeSelectView.val();
      if (this.currentView !== newView) {
        this.previousView = this.currentView;
        return this.currentView = newView;
      }
    };

    /*
      Selects the view which was previously selected (if any)
    */


    SwitchableContent.prototype.selectPreviousView = function() {
      if (this.previousView != null) {
        this.nodeSelectView.val(this.previousView);
        return this.updateVariables();
      }
    };

    /*
      Triggered when a different view was selected
    */


    SwitchableContent.prototype.eventSelectedViewChanged = function() {
      return this.updateVariables();
    };

    return SwitchableContent;

  })(Content);

  /*
  Wraps the content to be displayed inside a StoreWindow
  
  param window                    # The window which belongs to this content
  param options
  */


  StoreContent = (function(_super) {

    __extends(StoreContent, _super);

    StoreContent.VIEWS = {
      base64: "Base64",
      json: "Json"
    };

    function StoreContent(window, options) {
      this.window = window;
      this.options = options != null ? options : {};
      this.options.readonly = true;
      StoreContent.__super__.constructor.call(this, this.window, StoreContent.VIEWS, this.options);
    }

    /*
      Returns the initial data to be displayed
    */


    StoreContent.prototype.getInitialData = function() {
      return this.window.base64;
    };

    /*
      Triggered when a different view was selected
    */


    StoreContent.prototype.eventSelectedViewChanged = function() {
      StoreContent.__super__.eventSelectedViewChanged.call(this);
      switch (this.currentView) {
        case this.views.base64:
          return this.nodeData.val(this.window.base64);
        case this.views.json:
          return this.nodeData.val(this.window.json);
        default:
          return this.nodeData.val("Unbekannte Auswahl: '" + this.currentView + "'");
      }
    };

    return StoreContent;

  })(SwitchableContent);

  /*
  Wraps the content to be displayed inside a LoadWindow
  
  param window                    # The window which belongs to this content
  param options
  */


  LoadContent = (function(_super) {

    __extends(LoadContent, _super);

    function LoadContent(window, options) {
      this.window = window;
      this.options = options != null ? options : {};
      this.options.readonly = false;
      LoadContent.__super__.constructor.call(this, this.window, StoreContent.VIEWS, this.options);
    }

    /*
      Creates the initial nodeContent (the selection for the engine-type)
    
      Overrides the function from super()
    */


    LoadContent.prototype.create = function() {
      var _this = this;
      LoadContent.__super__.create.call(this);
      this.nodeButtonLoad = $("<button type='button'>Laden</button>");
      this.nodeFieldsetOptions.append(this.nodeButtonLoad);
      return this.nodeButtonLoad.click(function() {
        return _this.window.callbackLoad();
      });
    };

    /*
      Returns the initial data to be displayed
    */


    LoadContent.prototype.getInitialData = function() {
      if (LoadWindow.getLocalStorage() != null) {
        return LoadWindow.getLocalStorage();
      } else {
        return "";
      }
    };

    /*
      Triggered when the display type was changed
    */


    LoadContent.prototype.eventSelectedViewChanged = function() {
      LoadContent.__super__.eventSelectedViewChanged.call(this);
      switch (this.currentView) {
        case this.views.base64:
          return this.changeToBase64();
        case this.views.json:
          return this.changeToJson();
        default:
          return this.nodeData.val("Unbekannte Auswahl: '" + this.currentView + "'");
      }
    };

    /*
      Changes the currently displayed format to base64.
      Therefor the current input is converted. If this fails the previous format will be selected.
    */


    LoadContent.prototype.changeToBase64 = function() {
      var json, jsonPretty;
      jsonPretty = this.nodeData.val();
      if (jsonPretty.length !== 0) {
        try {
          json = JSON.stringify(LoadWindow.decodeJson(jsonPretty));
          return this.nodeData.val(StoreWindow.encodeToBase64(json));
        } catch (error) {
          this.selectPreviousView();
          return Main.console.error("JSON-Eingabe ist fehlerhaft (" + error + ")");
        }
      } else {
        return this.nodeData.val("");
      }
    };

    /*
      Changes the currently displayed format to json
      Therefor the current input is converted. If this fails the previous format will be selected.
    */


    LoadContent.prototype.changeToJson = function() {
      var base64, jsonPretty;
      base64 = this.nodeData.val();
      if (base64.length !== 0) {
        try {
          jsonPretty = JSON.stringify(LoadWindow.decodeBase64(base64), null, 1);
          return this.nodeData.val(jsonPretty);
        } catch (error) {
          this.selectPreviousView();
          return Main.console.error("Base64-Eingabe ist fehlerhaft (" + error + ")");
        }
      } else {
        return this.nodeData.val("");
      }
    };

    return LoadContent;

  })(SwitchableContent);

  /*
  Wraps the content to be displayed inside a TransformationWindow
  
  param transformation            # The Transformation which belongs to this content
  param window                    # The TransformationWindow which belongs to this content
  param options
  */


  TransformationContent = (function(_super) {

    __extends(TransformationContent, _super);

    TransformationContent.EXECUTION_SPAMMING_AFTER_MILLIS = 60000;

    function TransformationContent(transformation, window, options) {
      this.transformation = transformation;
      this.window = window;
      this.options = options != null ? options : {};
      this.execution = null;
      TransformationContent.__super__.constructor.call(this, this.window, this.options);
    }

    /*
      Creates the initial nodeContent (the selection for the engine-type)
    
      Overrides the function from super()
    */


    TransformationContent.prototype.create = function() {
      var _this = this;
      this.nodeContent = $("<div class='content'></div>");
      this.nodeFieldsetActions = $("<fieldset><legend>Aktionen</legend></fieldset>");
      this.nodeButtonStart = $("<button type='button'>Start</button>");
      this.nodeButtonStartAutomate = $("<button type='button'>Automatisieren</button>");
      this.nodeButtonForecast = $("<button type='button'>Laufzeitprognose</button>");
      this.nodeButtonDelete = $("<button type='button'>L&ouml;schen</button>");
      this.nodeScriptEngines = $("<textarea rows='4' readonly='1' class='scriptengines'></textarea>");
      this.nodeScript = $("<textarea rows='8' class='grow'></textarea>");
      this.setScriptEngine();
      this.nodeContent.append(this.nodeFieldsetActions);
      this.nodeFieldsetActions.append(this.nodeButtonStart);
      this.nodeFieldsetActions.append(this.nodeButtonForecast);
      this.nodeFieldsetActions.append(this.nodeButtonDelete);
      this.nodeFieldsetActions.append(this.nodeButtonStartAutomate);
      this.nodeContent.append(this.nodeFieldsetScript);
      this.nodeContent.append(this.nodeScriptEngines);
      this.nodeContent.append(this.nodeScript);
      this.nodeButtonStart.click(function() {
        return _this.eventButtonPressedStartStop();
      });
      this.nodeButtonStartAutomate.click(function() {
        return _this.eventButtonPressedStartAutomate();
      });
      this.nodeButtonForecast.click(function() {
        return _this.eventButtonPressedForecast();
      });
      return this.nodeButtonDelete.click(function() {
        return _this.eventButtonPressedDelete();
      });
    };

    /*
      Sets the text in the engine-line textarea.
    
      param text the new engine lines
    */


    TransformationContent.prototype.setScriptEngine = function() {
      return this.nodeScriptEngines.text(this.transformation.generateScriptHeader());
    };

    /*
      Sets the text in the big notaql-script textarea.
    
      param text the new script
    */


    TransformationContent.prototype.setScriptBody = function(text) {
      return this.nodeScript.text(text);
    };

    /*
      Gets the text in the big notaql-script textarea.
    
      return text the script-body
    */


    TransformationContent.prototype.getScriptBody = function() {
      return $.trim(this.nodeScript.val());
    };

    /*
      Triggered when the start/stop button is pressed
    */


    TransformationContent.prototype.eventButtonPressedStartStop = function() {
      var _this = this;
      if ((this.execution != null) && !(this.transformation.triggerTransformationId != null)) {
        return Main.console.error("Ausfuehrung laeuft schon");
      } else if (this.transformation.triggerTransformationId != null) {
        return this.transformation.stopTriggerTransformation();
      } else if (this.transformation.isValidExecution()) {
        Main.console.print("Transformation gestartet: " + (this.toString()));
        this.nodeButtonStart.text("Aktiv...");
        this.startTimeMs = (new Date).getTime();
        this.execution = new NotaqlExecution(this.transformation, {
          callbackFunction: (function(returnJson) {
            return _this.eventExecutionFinished(returnJson);
          }),
          advisor: this.automate != null ? true : void 0
        });
        if ((__indexOf.call(this.transformation.engineIn.type["arguments"], "triggerbased") >= 0 || __indexOf.call(this.transformation.engineIn.type["arguments"], "boolean_triggerbased") >= 0) && ((this.startTimeMs - this.finishTime) < TransformationContent.EXECUTION_SPAMMING_AFTER_MILLIS)) {
          return this.window.showMessage("Sie starten die Transformation sehr oft. Vermutlich ist eine triggerbasierte Ausfuehrung geeigneter.");
        }
      }
    };

    /*
      Triggered when the automate button is pressed
    */


    TransformationContent.prototype.eventButtonPressedStartAutomate = function() {
      var _this = this;
      if ((this.execution != null) || (this.transformation.triggerTransformationId != null)) {
        return Main.console.error("Die aktuelle Transformation muss zuerst abgeschlossen werden");
      } else if (this.transformation.isValidExecution()) {
        if ((this.automate != null) && this.automate) {
          this.nodeButtonStartAutomate.html("Wird deaktiviert ...");
          return new NotaqlExecution(this.transformation, {
            callbackFunction: (function(returnJson) {
              if (returnJson.response === "error") {
                return Main.console.error(returnJson.error_message);
              } else if (returnJson.response === "ok") {
                Main.console.print("Transformation wieder normal: " + (_this.toString()));
                _this.automate = null;
                _this.nodeButtonStartAutomate.html("Automatisieren");
                _this.nodeScript.attr("readonly", false);
                _this.transformation.engineIn.options.content.eventSetAutomated(false);
                return _this.transformation.engineOut.options.content.eventSetAutomated(false);
              }
            }),
            resetAdvisor: true
          });
        } else {
          Main.console.print("Transformation automatisiert: " + (this.toString()));
          this.automate = true;
          this.nodeButtonStartAutomate.html("&#10003; Automatisiert");
          this.nodeScript.attr("readonly", true);
          this.transformation.engineIn.options.content.eventSetAutomated(true);
          return this.transformation.engineOut.options.content.eventSetAutomated(true);
        }
      }
    };

    /*
      Triggered when the forecast button is pressed
    */


    TransformationContent.prototype.eventButtonPressedForecast = function() {
      var _this = this;
      if ((this.automate != null) && this.automate) {
        return Main.console.error("Laufzeitprognosen sind bei automatisierten Transformationen nicht moeglich");
      } else if (this.transformation.isValidExecution()) {
        Main.console.print("Erstelle Laufzeitprognose: " + (this.toString()));
        return new NotaqlExecution(this.transformation, {
          callbackFunction: (function(returnJson) {
            var runtimeMillis, similarityPercent, _ref;
            if (returnJson.response === "error") {
              return Main.console.error(returnJson.error_message);
            } else if (returnJson.response === "ok") {
              if (((_ref = returnJson.map) != null ? _ref.forecast : void 0) != null) {
                if (returnJson.map.forecast === "exception") {
                  return Main.console.error(returnJson.map.error_message);
                } else if (returnJson.map.forecast === "ok") {
                  runtimeMillis = returnJson.map.forecast_result.runtimeMillis;
                  similarityPercent = Math.round(returnJson.map.forecast_result.similarity * 100);
                  Main.console.print("Die zu '" + (_this.toString()) + "' aehnlichsten Transformationen brauchten durchschnittlich " + runtimeMillis + " ms (Aehnlichkeit: " + similarityPercent + "%)");
                  return _this.window.showMessage("Erwartete Laufzeit: " + runtimeMillis + " ms (" + similarityPercent + "%)");
                }
              }
            }
          }),
          forecast: true
        });
      }
    };

    /*
      Triggered when the delete button is pressed
    */


    TransformationContent.prototype.eventButtonPressedDelete = function() {
      if ((this.execution != null) || (this.transformation.triggerTransformationId != null) || (this.automate != null)) {
        return Main.console.error("Die aktuelle Transformation muss zuerst abgeschlossen werden");
      } else {
        if (confirm("Wirklich die Transformation loeschen?")) {
          if ((this.automate != null) && this.automate) {
            new NotaqlExecution(this.transformation, {
              resetAdvisor: true
            });
          }
          return this.transformation.close();
        }
      }
    };

    /*
      Clears the currently running execution (only in the UI)
    */


    TransformationContent.prototype.clearExecution = function() {
      this.nodeButtonStart.text("Start");
      this.execution = null;
      return this.transformation.triggerTransformationId = null;
    };

    /*
      Triggered when the execution of the script is finished
    
      param returnJson the json-data returned by the NotaqlExecution
    */


    TransformationContent.prototype.eventExecutionFinished = function(returnJson) {
      var key, newvalue, totalTimeMs, _ref, _ref1, _ref2, _ref3, _ref4;
      this.finishTime = (new Date).getTime();
      totalTimeMs = this.finishTime - this.startTimeMs;
      Main.console.print("Ausfuehrung abgeschlossen: " + (this.toString()) + " (" + totalTimeMs + " ms)");
      if (returnJson.response === "error") {
        Main.console.error(returnJson.error_message);
      } else if (returnJson.response === "ok") {
        if (((_ref = returnJson.map) != null ? _ref.new_values : void 0) != null) {
          if (returnJson.map.new_values.in_engine != null) {
            _ref1 = returnJson.map.new_values.in_engine;
            for (key in _ref1) {
              newvalue = _ref1[key];
              this.transformation.engineIn.setArgument(key, newvalue);
            }
          }
          if (returnJson.map.new_values.out_engine != null) {
            _ref2 = returnJson.map.new_values.out_engine;
            for (key in _ref2) {
              newvalue = _ref2[key];
              this.transformation.engineOut.setArgument(key, newvalue);
            }
          }
        }
        if (((_ref3 = returnJson.map) != null ? _ref3.messages : void 0) != null) {
          if (returnJson.map.messages.in_engine != null) {
            this.transformation.engineIn.showMessages(returnJson.map.messages.in_engine);
          }
          if (returnJson.map.messages.out_engine != null) {
            this.transformation.engineIn.showMessages(returnJson.map.messages.out_engine);
          }
        }
        if (((_ref4 = returnJson.map) != null ? _ref4.trigger : void 0) != null) {
          if (returnJson.map.trigger === "exception") {
            Main.console.error(returnJson.map.error_message);
          } else if (returnJson.map.trigger === "ok") {
            this.transformation.eventTriggerTransformationStarted(returnJson.map);
          }
        }
      }
      if (this.transformation.triggerTransformationId == null) {
        return this.clearExecution();
      }
    };

    /*
      Erstellt eine Stringrepraesentation des Objekts
    
      return string
    */


    TransformationContent.prototype.toString = function() {
      return this.window.generateTitle();
    };

    return TransformationContent;

  })(Content);

  /*
  A window on the dashboard
  
  param options =
    parent          # Parent for the new window-node.
    id              # ID for the window.
    [classes]       # Additional classes for the window
    title           # Title for the window.
    content         # Content-node for the window.
    hidden          # Whether or not the window will be spawned with css("display", "hidden")
    nodesAdditional # Additional DOM-nodes to append to the window (e.g. transformation-connectors).
    optimalSize     # Resize the window after creation so it fits the content perfectly
    offset          # The window will be spawned at the given offset (see jQuery.offset())
  */


  Window = (function() {

    Window.DEFAULT_PARENT = "body";

    Window.DEFAULT_TITLE = "Neues Fenster";

    Window.DEFAULT_HIDDEN = false;

    Window.DEFAULT_OPTIMAL_SIZE = false;

    Window.nextWindowId = 0;

    Window.currentMaxZIndexWindow = null;

    Window.minWindowOffset = 5;

    Window.maxWindowOffset = 80;

    Window.nextWindowOffsetStep = 11;

    Window.nextWindowOffset = Window.minWindowOffset;

    function Window(options) {
      this.options = options != null ? options : {};
      this.hideMessage = __bind(this.hideMessage, this);

      this.repositionMessage = __bind(this.repositionMessage, this);

      if (this.options.parent == null) {
        this.options.parent = $(Window.DEFAULT_PARENT);
      }
      if (this.options.title == null) {
        this.options.title = Window.DEFAULT_TITLE;
      }
      if (this.options.hidden == null) {
        this.options.hidden = Window.DEFAULT_HIDDEN;
      }
      if (this.options.nodesAdditional == null) {
        this.options.nodesAdditional = [];
      }
      if (this.options.id == null) {
        this.options.id = "window" + (Window.nextWindowId++);
      }
      if (this.options.content == null) {
        this.options.content = new Content();
      }
      if (this.options.optimalSize == null) {
        this.options.optimalSize = Window.DEFAULT_OPTIMAL_SIZE;
      }
      this.create();
      if (this.options.optimalSize) {
        this.autoResize(this.options.optimalSize.width, this.options.optimalSize.height);
      }
      this.moveToFront();
    }

    /*
      Create the window inside the parent
    */


    Window.prototype.create = function() {
      var nodeAdditional, offset, _class, _i, _j, _len, _len1, _ref, _ref1;
      this.nodeTitle = $("<span class='title'>" + this.options.title + "</span>");
      this.nodeButtonMinimize = $("<span class='button buttonminimize'>_</span>");
      this.nodeButtonMaximize = $("<span class='button buttonmaximize'>&#9723;</span>");
      this.nodeButtonClose = $("<span class='buttonclose'>x</span>");
      this.nodeButtons = $("<span class='buttons'></span>");
      this.nodeTitlebar = $("<div class='titlebar'></div>");
      this.nodeContent = $("<div class='content'></div>");
      this.nodeWindow = $("<div id='" + this.options.id + "' class='window'></div>");
      if (this.options.hidden) {
        this.nodeWindow.css("display", "none");
      }
      if (this.options.offset) {
        this.nodeWindow.offset(this.options.offset);
      } else if (!(this.options.offset != null)) {
        offset = "" + Window.nextWindowOffset + "%";
        Window.nextWindowOffset = Window.nextWindowOffset + Window.nextWindowOffsetStep;
        if (Window.nextWindowOffset > Window.maxWindowOffset) {
          Window.nextWindowOffset = Window.minWindowOffset + (Window.nextWindowOffset - Window.maxWindowOffset);
        }
        this.nodeWindow.css({
          top: offset,
          left: offset
        });
      }
      if (this.options.classes != null) {
        _ref = this.options.classes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _class = _ref[_i];
          this.nodeWindow.addClass(_class);
        }
      }
      this.nodeTitlebar.append(this.nodeTitle);
      this.nodeButtons.append(this.nodeButtonMinimize);
      this.nodeButtons.append(this.nodeButtonMaximize);
      this.nodeButtons.append(this.nodeButtonClose);
      this.nodeTitlebar.append(this.nodeButtons);
      this.nodeContent.append(this.options.content.nodeContent);
      this.nodeWindow.append(this.nodeTitlebar);
      this.nodeWindow.append(this.nodeContent);
      _ref1 = this.options.nodesAdditional;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        nodeAdditional = _ref1[_j];
        this.nodeWindow.append(nodeAdditional);
      }
      this.options.parent.append(this.nodeWindow);
      return this.enableWindowFeatures();
    };

    /*
      Enables window features
    */


    Window.prototype.enableWindowFeatures = function() {
      this.enableDragable();
      this.enableResizable();
      this.enableMinimize();
      this.enableMaximize();
      this.enableClose();
      return this.enableClickWindow();
    };

    /*
      Makes the window draggable
    */


    Window.prototype.enableDragable = function() {
      var _this = this;
      return this.nodeWindow.draggable({
        start: function() {
          return _this.eventDragged();
        },
        drag: function() {
          return _this.eventDragged();
        },
        stop: function() {
          return _this.eventDragged();
        }
      });
    };

    /*
      Executed at drag-events
    */


    Window.prototype.eventDragged = function() {
      $("#svg").attr("height", "100%");
      return this.repositionMessage();
    };

    /*
      Makes the window draggable
    */


    Window.prototype.enableResizable = function() {
      var _this = this;
      return this.nodeWindow.resizable({
        handles: "n, e, w, s",
        start: function() {
          return _this.eventResized();
        },
        resize: function() {
          return _this.eventResized();
        },
        stop: function() {
          return _this.eventResized();
        },
        containment: "document"
      });
    };

    /*
      Executed at resize-events
    */


    Window.prototype.eventResized = function() {
      return this.hideMessage();
    };

    /*
      Makes the window minimizeable
    */


    Window.prototype.enableMinimize = function() {
      var _this = this;
      return this.nodeButtonMinimize.click(function() {
        return _this.eventClickButtonMinimize();
      });
    };

    /*
      Executed when the user wants to change the minimize-state of a window
    */


    Window.prototype.eventClickButtonMinimize = function() {
      if (this.getIsMinimized()) {
        return this.setIsMinimized(false);
      } else {
        return this.setIsMinimized(true);
      }
    };

    /*
      Makes the window maximizeable
    */


    Window.prototype.enableMaximize = function() {
      var _this = this;
      return this.nodeButtonMaximize.click(function() {
        return _this.eventClickButtonMaximize();
      });
    };

    /*
      Executed when the user wants to change the maximize-state of a window
    */


    Window.prototype.eventClickButtonMaximize = function() {
      if (this.getIsMaximized()) {
        return this.setIsMaximized(false);
      } else {
        return this.setIsMaximized(true);
      }
    };

    /*
      Makes the window closeable
    */


    Window.prototype.enableClose = function() {
      var _this = this;
      return this.nodeButtonClose.click(function() {
        return _this.eventClickButtonCloes();
      });
    };

    /*
      Executed when the user wants to close the window
    */


    Window.prototype.eventClickButtonCloes = function() {
      return this.close();
    };

    /*
      Makes the windows clickable
    */


    Window.prototype.enableClickWindow = function() {
      var _this = this;
      return this.nodeWindow.click(function() {
        return _this.eventClickWindow();
      });
    };

    /*
      Executed when the user wants to close the window
    */


    Window.prototype.eventClickWindow = function() {
      return this.moveToFront();
    };

    /*
      Changes the title for this window
    
      param newTitle
    */


    Window.prototype.setTitle = function(newTitle) {
      if (newTitle == null) {
        newTitle = "";
      }
      return this.nodeTitle.text(newTitle);
    };

    /*
      Gets the display-state for this widnow
    
      return true if displayed, false otherwise
    */


    Window.prototype.getIsDisplayed = function() {
      return this.nodeWindow.css("display").toLowerCase() !== "none";
    };

    /*
      Changes the display-state for this window (hidden / displayed)
    
      param newState
    */


    Window.prototype.setIsDisplayed = function(newState, animate) {
      if (newState == null) {
        newState = true;
      }
      if (animate == null) {
        animate = true;
      }
      if (this.getIsDisplayed() && !newState) {
        if (animate) {
          return this.nodeWindow.fadeOut("fast");
        } else {
          return this.nodeWindow.css("display", "none");
        }
      } else if (!this.getIsDisplayed() && newState) {
        if (animate) {
          return this.nodeWindow.fadeIn("fast");
        } else {
          return this.nodeWindow.css("display", "block");
        }
      }
    };

    /*
      Gets the minimized-state for this window
    
      return true if minimized, false otherwise
    */


    Window.prototype.getIsMinimized = function() {
      if (this.stateIsMinimized == null) {
        return false;
      } else {
        return this.stateIsMinimized;
      }
    };

    /*
      Changes the minimized state for this window (minimized / un-minimized)
    
      param newState
    */


    Window.prototype.setIsMinimized = function(newState, animate) {
      var _this = this;
      if (newState == null) {
        newState = false;
      }
      if (animate == null) {
        animate = true;
      }
      if (this.getIsMinimized() && !newState) {
        this.nodeContent.appendTo(this.nodeWindow);
        if (animate) {
          this.nodeWindow.animate({
            height: this.minimizePrevHeight
          }, function() {
            if (_this.options.optimalSize && _this.options.optimalSize.height) {
              _this.nodeWindow.height("auto");
            }
            return _this.eventResized();
          });
        } else {
          this.nodeWindow.height(this.minimizePrevHeight);
          this.eventResized();
        }
        this.stateIsMinimized = newState;
      } else if (!this.getIsMinimized() && newState) {
        this.minimizePrevHeight = this.nodeWindow.height();
        if (animate) {
          this.nodeWindow.animate({
            height: this.nodeWindow.css("min-height")
          }, function() {
            _this.nodeContent.detach();
            return _this.eventResized();
          });
        } else {
          this.nodeWindow.height(this.nodeWindow.css("min-height"));
          this.nodeContent.detach();
          this.eventResized();
        }
        this.stateIsMinimized = newState;
      }
      return this.eventResized();
    };

    /*
      Gets the maximized-state for this window
    
      return true if maximized, false otherwise
    */


    Window.prototype.getIsMaximized = function() {
      if (this.stateIsMaximized == null) {
        return false;
      } else {
        return this.stateIsMaximized;
      }
    };

    /*
      Changes the maximized state for this window (maximized / un-maximized)
    
      param newState
    */


    Window.prototype.setIsMaximized = function(newState) {
      if (newState == null) {
        newState = false;
      }
      if (this.getIsMaximized() && !newState) {
        this.setIsDisplayed(false, false);
        this.setIsMinimized(this.maximizePrev.wasMinimized, false);
        this.minimizePrevHeight = this.maximizePrev.minimizePrevHeight;
        this.nodeWindow.css({
          top: this.maximizePrev.position.top,
          left: this.maximizePrev.position.left,
          width: this.maximizePrev.width,
          height: this.maximizePrev.height
        });
        this.nodeWindow.removeClass("nottransparent");
        this.setIsDisplayed(true, false);
        this.stateIsMaximized = newState;
      } else if (!this.getIsMaximized() && newState) {
        this.maximizePrev = {
          position: this.nodeWindow.position(),
          width: this.nodeWindow.width(),
          height: this.nodeWindow.height(),
          wasMinimized: this.getIsMinimized(),
          minimizePrevHeight: this.minimizePrevHeight
        };
        this.setIsDisplayed(false, false);
        this.setIsMinimized(false, false);
        this.nodeWindow.css({
          top: "2%",
          left: "2%",
          width: "96%",
          height: "96%"
        });
        this.nodeWindow.addClass("nottransparent");
        this.setIsDisplayed(true, false);
        this.stateIsMaximized = newState;
      }
      return this.eventResized();
    };

    /*
      Closes the window
    */


    Window.prototype.close = function() {
      return this.nodeWindow.fadeOut("fast");
    };

    /*
      Moves the window to the front of the dashboard (z-index increment)
    */


    Window.prototype.moveToFront = function() {
      var nextZIndex;
      if (Window.currentMaxZIndexWindow != null) {
        nextZIndex = Window.currentMaxZIndexWindow.nodeWindow.zIndex() + 1;
      } else {
        nextZIndex = 1000;
      }
      this.nodeWindow.zIndex(nextZIndex);
      return Window.currentMaxZIndexWindow = this;
    };

    /*
      Resizes the window to perfectly fit the content
    
      param resizeWidth true if width shall be resized, false otherwise
      param resizeHeight true if height shall be resized, false otherwise
    */


    Window.prototype.autoResize = function(resizeWidth, resizeHeight) {
      if (resizeWidth == null) {
        resizeWidth = true;
      }
      if (resizeHeight == null) {
        resizeHeight = true;
      }
      if (resizeWidth) {
        this.nodeWindow.width("auto");
      }
      if (resizeHeight) {
        this.nodeWindow.height("auto");
      }
      return this.eventResized();
    };

    /*
      Changes the content of this window
    
      param newContent Instance of class Content
    */


    Window.prototype.setContent = function(newContent) {
      this.options.content = newContent;
      this.nodeContent.append(this.options.content.nodeContent);
      return this.eventContentChanged();
    };

    /*
      Executed when the content changes
    */


    Window.prototype.eventContentChanged = function() {
      if (this.options.optimalSize) {
        return this.autoResize(this.options.optimalSize.width, this.options.optimalSize.height);
      }
    };

    /*
      Shows multiple messages below the window (e.g. a hint on how to optimize the query)
    
      param texts the texts to show (array)
    */


    Window.prototype.showMessages = function(texts) {
      return this.showMessage(texts.join("\n"));
    };

    /*
      Shows a message below the window (e.g. a hint on how to optimize the query)
    
      param text the text to show
    */


    Window.prototype.showMessage = function(text) {
      var _this = this;
      this.hideMessage();
      this.nodeWindow.attr("title", text);
      this.createTooltip();
      return this.tooltip = setTimeout(function() {
        return _this.hideMessage();
      }, 10000);
    };

    /*
      Creates the tooltip
    */


    Window.prototype.createTooltip = function() {
      this.nodeWindow.tooltip({
        show: false,
        hide: {
          duration: 9999999
        }
      });
      return this.nodeWindow.tooltip("open");
    };

    /*
      Re-sets the position of the message (if any)
    */


    Window.prototype.repositionMessage = function() {
      if ((this.tooltip != null) && this.tooltip) {
        this.nodeWindow.tooltip("destroy");
        return this.createTooltip();
      }
    };

    /*
      Hides the message (if any)
    */


    Window.prototype.hideMessage = function() {
      if ((this.tooltip != null) && this.tooltip) {
        this.nodeWindow.tooltip("destroy");
        this.nodeWindow.removeAttr("title");
        clearTimeout(this.tooltip);
        return this.tooltip = false;
      }
    };

    return Window;

  })();

  /*
  A window on the dashboard used for the notaql-configuration
  
  param options
  */


  ConfigurationWindow = (function(_super) {

    __extends(ConfigurationWindow, _super);

    ConfigurationWindow.DEFAULT_TITLE = "Konfiguration";

    function ConfigurationWindow(options) {
      this.options = options != null ? options : {};
      this.eventResponseSetConfiguration = __bind(this.eventResponseSetConfiguration, this);

      this.eventResponseGetConfiguration = __bind(this.eventResponseGetConfiguration, this);

      this.cachedKeyValues = {};
      if (this.options.title == null) {
        this.options.title = ConfigurationWindow.DEFAULT_TITLE;
      }
      this.options.autoresize = true;
      this.options.classes = ["configurationwindow"];
      this.options.content = new KeyValueContent(this, this.options);
      this.options.optimalSize = {
        width: true,
        height: true
      };
      this.requestKeyValues();
      ConfigurationWindow.__super__.constructor.call(this, this.options);
    }

    /*
      Gets the configuration from the server.
      Note: Not the current but the cached version will be send to the window. The
        window will change at the moment the server responds with the current values
    
      return the cached configuration
    */


    ConfigurationWindow.prototype.requestKeyValues = function() {
      var serverRequestGetConfiguration;
      serverRequestGetConfiguration = new ServerRequest(ServerRequest.REQUEST_TYPE_CONFIGURATION_GET);
      serverRequestGetConfiguration.addDoneFunction(this.eventResponseGetConfiguration);
      return this.cachedKeyValues;
    };

    /*
      Returns the currently cached values from the server.
    
      return the cached configuration
    */


    ConfigurationWindow.prototype.getKeyValues = function() {
      return this.cachedKeyValues;
    };

    /*
      Triggered when the server responds with new values.
      Updates the content.
    
      param returnJson
    */


    ConfigurationWindow.prototype.eventResponseGetConfiguration = function(returnJson) {
      if ((returnJson != null ? returnJson.response : void 0) === "ok") {
        this.cachedKeyValues = returnJson.map;
        return this.options.content.createKeyValueInputs();
      } else {
        return Main.console.error("Fehler: Konfiguration konnten nicht vom Server abgeholt werden");
      }
    };

    /*
      Sends the configuration to the server
    
      param keyValues
    */


    ConfigurationWindow.prototype.setKeyValues = function(keyValues) {
      var serverRequestSetConfiguration;
      this.options.content.nodeButtonStore.text("Speichere...");
      serverRequestSetConfiguration = new ServerRequest(ServerRequest.REQUEST_TYPE_CONFIGURATION_SET, keyValues);
      return serverRequestSetConfiguration.addDoneFunction(this.eventResponseSetConfiguration);
    };

    /*
      Triggered when the server responds to the set_configuration request.
    
      param returnJson
    */


    ConfigurationWindow.prototype.eventResponseSetConfiguration = function(returnJson) {
      if ((returnJson != null ? returnJson.response : void 0) === "ok") {
        this.close();
        return Main.console.print("Neue Konfiguration gespeichert und geladen");
      } else {
        this.options.content.nodeButtonStore.text("Speichern");
        return Main.console.error("Fehler: Konfiguration konnten nicht beim Server gespeichert werden");
      }
    };

    return ConfigurationWindow;

  })(Window);

  /*
  A console-window on the dashboard
  
  param options =
    title                         # Name of the window (displayed in the titlebar)
    windowAutoscroll              # Whether the window should automatically scroll down after appending text to it
  */


  ConsoleWindow = (function(_super) {

    __extends(ConsoleWindow, _super);

    ConsoleWindow.DEFAULT_TITLE = "Konsole";

    function ConsoleWindow(options) {
      this.options = options != null ? options : {};
      if (this.options.title == null) {
        this.options.title = ConsoleWindow.DEFAULT_TITLE;
      }
      this.options.id = "console_window";
      this.options.offset = false;
      this.options.classes = ["consolewindow"];
      this.options.content = new ConsoleContent(this, this.options);
      ConsoleWindow.__super__.constructor.call(this, this.options);
    }

    /*
      Appends a text to the console-textarea.
    
      This is a proxy to the ConsoleContent
    
      param text
    */


    ConsoleWindow.prototype.append = function(text) {
      if (text == null) {
        text = "";
      }
      return this.options.content.append(text);
    };

    /*
      Overwrites the function from Window
    */


    ConsoleWindow.prototype.create = function() {
      ConsoleWindow.__super__.create.call(this);
      this.nodeButtonClear = $("<span class='button'>&#9666;</span>");
      this.nodeButtons.prepend(this.nodeButtonClear);
      return this.enableClear();
    };

    /*
      Makes the window clearable (clearing the content)
    */


    ConsoleWindow.prototype.enableClear = function() {
      var _this = this;
      return this.nodeButtonClear.click(function() {
        return _this.eventClickButtonClear();
      });
    };

    /*
      Executed when the user wants to clear the window
    */


    ConsoleWindow.prototype.eventClickButtonClear = function() {
      return this.options.content.clear();
    };

    return ConsoleWindow;

  })(Window);

  /*
  A console-window on the dashboard
  
  param options =
    title                         # Name of the window (displayed in the titlebar)
    windowAutoscroll              # Whether the window should automatically scroll down after appending text to it
    {arguments}                   # The initial arguments of the server (e.g. "csv_path")
  */


  EngineWindow = (function(_super) {

    __extends(EngineWindow, _super);

    EngineWindow.DEFAULT_TITLE = "Neue Engine";

    EngineWindow.lastConnectorClicked = null;

    function EngineWindow(options) {
      var _this = this;
      this.options = options != null ? options : {};
      if (this.options.title == null) {
        this.options.title = EngineWindow.DEFAULT_TITLE;
      }
      this.options.classes = ["enginewindow"];
      this.options.optimalSize = {
        width: true,
        height: true
      };
      this.nodeLeftConnectionPoint = $("<span class='transformationConnectionPoint transformationConnectionPointLeft'></span>");
      this.nodeRightConnectionPoint = $("<span class='transformationConnectionPoint transformationConnectionPointRight'></span>");
      this.nodeLeftConnector = $("<span class='transformationConnector transformationConnectorLeft'>&#8226;</span>");
      this.nodeRightConnector = $("<span class='transformationConnector transformationConnectorRight'>&#8226;</span>");
      if (this.options.nodesAdditional == null) {
        this.options.nodesAdditional = [];
      }
      this.options.nodesAdditional = this.options.nodesAdditional.concat([this.nodeLeftConnectionPoint, this.nodeRightConnectionPoint, this.nodeLeftConnector, this.nodeRightConnector]);
      this.nodeLeftConnector.click(function() {
        return _this.eventLeftConnectorClicked();
      });
      this.nodeRightConnector.click(function() {
        return _this.eventRightConnectorClicked();
      });
      EngineWindow.__super__.constructor.call(this, this.options);
      this.setContent(new EngineContent(this, this.options));
    }

    /*
      Along with the information which connector was clicked last a new transformation
      is created (if it will be valid)
    */


    EngineWindow.createNewTransformation = function(clickEvent) {
      var inEngine, outEngine;
      if (this.lastConnectorClicked == null) {
        clickEvent.connector.addClass("transformationConnectorClicked");
        return this.lastConnectorClicked = clickEvent;
      } else {
        this.lastConnectorClicked.connector.removeClass("transformationConnectorClicked");
        try {
          if (this.lastConnectorClicked.isRightConnector && !clickEvent.isRightConnector) {
            inEngine = this.lastConnectorClicked.engine;
            outEngine = clickEvent.engine;
          } else if (clickEvent.isRightConnector && !this.lastConnectorClicked.isRightConnector) {
            inEngine = clickEvent.engine;
            outEngine = this.lastConnectorClicked.engine;
          } else {
            Main.console.error("Es muss ein linker und ein rechter Connector genutzt werden");
            throw "Invalid Connectors";
          }
          try {
            new Transformation(inEngine, outEngine);
          } catch (_error) {}
        } catch (_error) {}
        return this.lastConnectorClicked = null;
      }
    };

    /*
      Triggered when the engine-type was changed to another one.
    */


    EngineWindow.prototype.eventEngineTypeChanged = function() {
      return this.setTitle(this.type.typeName);
    };

    return EngineWindow;

  })(Window);

  /*
  A window on the dashboard used for displaying the stored data.
  
  param base64
  param json
  param options
  */


  StoreWindow = (function(_super) {

    __extends(StoreWindow, _super);

    StoreWindow.LOCALSTORAGE_KEY = "storedtransformation";

    StoreWindow.DEFAULT_TITLE = "Gespeichert!";

    function StoreWindow(base64, json, options) {
      this.base64 = base64;
      this.json = json;
      this.options = options != null ? options : {};
      if (this.options.title == null) {
        this.options.title = StoreWindow.DEFAULT_TITLE;
      }
      this.options.classes = ["storewindow", "storeloadwindow"];
      this.options.content = new StoreContent(this, this.options);
      StoreWindow.__super__.constructor.call(this, this.options);
    }

    /*
      Sets the data which is stored in the local storage
    
      param base64 encoded string
    */


    StoreWindow.setLocalStorage = function(base64) {
      return localStorage.setItem(StoreWindow.LOCALSTORAGE_KEY, base64);
    };

    /*
      Encodes a jsonString to base64
    
      param jsonString
      return base64String
    */


    StoreWindow.encodeToBase64 = function(jsonString) {
      return $.base64.btoa($.trim(jsonString), true);
    };

    return StoreWindow;

  })(Window);

  /*
  A window on the dashboard used for entering serialized data.
  
  param callbackFunctionLoad    # Callback function which is called with the data the user wants to load
  param options
  */


  LoadWindow = (function(_super) {

    __extends(LoadWindow, _super);

    LoadWindow.LOCALSTORAGE_KEY = StoreWindow.LOCALSTORAGE_KEY;

    LoadWindow.DEFAULT_TITLE = "Dashboard laden";

    function LoadWindow(callbackFunctionLoad, options) {
      this.callbackFunctionLoad = callbackFunctionLoad;
      this.options = options != null ? options : {};
      if (this.options.title == null) {
        this.options.title = LoadWindow.DEFAULT_TITLE;
      }
      this.options.classes = ["loadwindow", "storeloadwindow"];
      this.options.content = new LoadContent(this, this.options);
      LoadWindow.__super__.constructor.call(this, this.options);
    }

    /*
      Calls the callback function which loads the data
    */


    LoadWindow.prototype.callbackLoad = function() {
      var data, decodedData, format;
      data = this.options.content.nodeData.val();
      format = this.options.content.currentView;
      decodedData = null;
      if (format === this.options.content.views.base64) {
        try {
          decodedData = LoadWindow.decodeBase64(data);
          this.callbackFunctionLoad(decodedData);
        } catch (error) {
          Main.console.error("Base64-Eingabe ist fehlerhaft (" + error + ")");
        }
      } else if (format === this.options.content.views.json) {
        try {
          decodedData = LoadWindow.decodeJson(data);
          this.callbackFunctionLoad(decodedData);
        } catch (error) {
          Main.console.error("JSON-Eingabe ist fehlerhaft (" + error + ")");
        }
      } else {
        Main.console.error("Unbekanntes Format: '" + callbackData.format + "'");
      }
      if (decodedData != null) {
        return this.close();
      }
    };

    /*
      Gets the data which is stored in the local storage
    
      return base64 encoded string or null
    */


    LoadWindow.getLocalStorage = function() {
      return $.trim(localStorage.getItem(LoadWindow.LOCALSTORAGE_KEY));
    };

    /*
      Decodes a base64 encoded json string into an object
    
      param base64
      return object or empty string
    */


    LoadWindow.decodeBase64 = function(base64) {
      if (!(base64 != null) || base64.length === 0) {
        return "";
      } else {
        return JSON.parse($.base64.atob($.trim(base64), true));
      }
    };

    /*
      Decodes a json string into an object
    
      param jsonString
      return object or empty string
    */


    LoadWindow.decodeJson = function(jsonString) {
      if (!(jsonString != null) || jsonString.length === 0) {
        return "";
      } else {
        return JSON.parse($.trim(jsonString));
      }
    };

    return LoadWindow;

  })(Window);

  /*
  A transformation-window on the dashboard. Belongs to a Transformation.
  
  param options
  */


  TransformationWindow = (function(_super) {

    __extends(TransformationWindow, _super);

    TransformationWindow.DEFAULT_TITLE = "Transformation";

    function TransformationWindow(transformation, options) {
      this.transformation = transformation;
      this.options = options != null ? options : {};
      if (this.options.title == null) {
        this.options.title = this.generateTitle();
      }
      this.options.classes = ["transformationwindow"];
      this.options.offset = this.transformation.nodeLine.offset();
      this.options.content = new TransformationContent(this.transformation, this, this.options);
      TransformationWindow.__super__.constructor.call(this, this.options);
    }

    /*
      Triggered when one of the attached engines changed.
    */


    TransformationWindow.prototype.eventEngineChanged = function() {
      this.setTitle(this.generateTitle());
      return this.options.content.setScriptEngine(this.transformation.generateScriptHeader());
    };

    /*
      Generates the title of the window
    */


    TransformationWindow.prototype.generateTitle = function() {
      var _ref, _ref1;
      return "" + ((_ref = this.transformation.engineIn.type) != null ? _ref.typeName : void 0) + " -> " + ((_ref1 = this.transformation.engineOut.type) != null ? _ref1.typeName : void 0);
    };

    /*
      Overwrites the function from Window
    */


    TransformationWindow.prototype.close = function() {
      TransformationWindow.__super__.close.call(this);
      return this.transformation.eventFocusLost();
    };

    return TransformationWindow;

  })(Window);

  /*
  A line which is for example used for representing transformations
  
  param options
  */


  Line = (function() {

    Line.DEFAULT_PARENT = "#svg";

    function Line(options) {
      this.options = options != null ? options : {};
      if (this.options.parent == null) {
        this.options.parent = $(Line.DEFAULT_PARENT);
      }
      this.nodeLine = $(document.createElementNS("http://www.w3.org/2000/svg", "line"));
      this.options.parent.append(this.nodeLine);
    }

    /*
      Redraws the transformation line.
    */


    Line.prototype.redraw = function(x1, y1, x2, y2) {
      if (x1 == null) {
        x1 = 0;
      }
      if (y1 == null) {
        y1 = 0;
      }
      if (x2 == null) {
        x2 = 0;
      }
      if (y2 == null) {
        y2 = 0;
      }
      return this.nodeLine.attr({
        "x1": x1,
        "y1": y1,
        "x2": x2,
        "y2": y2
      });
    };

    /*
      Removes the line from the dashboard
    */


    Line.prototype.close = function() {
      return this.nodeLine.remove();
    };

    return Line;

  })();

  /*
  An engine which is currently displayed on the dashboard (in a EngineWindow)
  
  param options =
    server            # Contains informations from the server
    engineid          # The initial @id of the engine
    typeName          # The initial type of the server (e.g. "csv")
    {arguments}       # The initial arguments of the server (e.g. "csv_path")
    [callbackClosed]  # Functions to be called on close-events.
  */


  Engine = (function(_super) {

    __extends(Engine, _super);

    function Engine(options) {
      var areArgumentsValid, argument, passedType, _i, _len, _ref,
        _this = this;
      this.options = options != null ? options : {};
      this.type = null;
      this.transformations = [];
      if (this.options.engineid != null) {
        this.id = this.options.engineid;
      } else {
        this.id = Main.randomId();
      }
      if (this.options.typeName != null) {
        passedType = this.options.server.getEngine(this.options.typeName);
        if (passedType == null) {
          Main.console.error("Server hat keine Engine mit dem uebergebenen Typ '" + this.options.typeName + "' bereitgestellt");
          this.options.typeName = null;
          this.options["arguments"] = null;
        } else {
          this.type = passedType;
        }
      }
      if (this.options["arguments"]) {
        if (this.type == null) {
          Main.console.error("Es wurden Argumente ohne einen typeName uebergeben");
          this.options["arguments"] = null;
        } else {
          areArgumentsValid = true;
          _ref = this.options["arguments"];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            argument = _ref[_i];
            if (__indexOf.call(this.type["arguments"], argument) < 0) {
              Main.console.error("Uebergebenes Argument '" + argument + "' wurde vom Server fuer den Typ " + this.type.typeName + " nicht bereitgestellt");
              areArgumentsValid = false;
            }
            if (!areArgumentsValid) {
              this.options["arguments"] = null;
            }
          }
        }
      }
      $(window).resize(function() {
        return _this.redrawAttachedTransformationLines();
      });
      Engine.__super__.constructor.call(this, this.options);
    }

    /*
      Serializes this engine-object
    
      return one object containing everything needed for restoring the object
    */


    Engine.prototype.serialize = function() {
      var argument, serialized, transformation, value, _i, _len, _ref, _ref1, _ref2;
      serialized = {
        id: this.id,
        typeName: (_ref = this.type) != null ? _ref.typeName : void 0
      };
      _ref1 = this.getArguments();
      for (argument in _ref1) {
        value = _ref1[argument];
        if (serialized["arguments"] == null) {
          serialized["arguments"] = {};
        }
        serialized["arguments"][argument] = value;
      }
      _ref2 = this.getTransformations();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        transformation = _ref2[_i];
        if (serialized.transformations == null) {
          serialized.transformations = [];
        }
        serialized.transformations.push(transformation.serialize());
      }
      return serialized;
    };

    /*
      Creates an instance based on data which was previously generated by Engine.serialize()
    
      param serializedData
      return the new instance
    */


    Engine.deserialize = function(serializedData, options) {
      if (serializedData.id != null) {
        options.engineid = serializedData.id;
      }
      if (serializedData.typeName != null) {
        options.typeName = serializedData.typeName;
      }
      if (serializedData["arguments"] != null) {
        options["arguments"] = serializedData["arguments"];
      }
      return new Engine(options);
    };

    /*
      Registers a transformation to this engine.
    
      param transformation
      param isInEngine whether this engine is the IN-ENGINE for this transformation. if it is false it is the OUT-ENGINE
    */


    Engine.prototype.registerTransformation = function(transformation, isInEngine) {
      return this.transformations.push({
        object: transformation,
        isInEngine: isInEngine
      });
    };

    /*
      Checks if the transformation is connected to this engine
    
      return the engine if it is, false otherwise
    */


    Engine.prototype.isTransformationConnected = function(transformation) {
      var storedTransformation, _i, _len, _ref;
      _ref = this.transformations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        storedTransformation = _ref[_i];
        if (storedTransformation.object === transformation) {
          return storedTransformation;
        }
      }
      return false;
    };

    /*
      Reverts a registration for a transformation to this engine.
    */


    Engine.prototype.unregisterTransformation = function(transformation) {
      var isTransformationConnected;
      isTransformationConnected = this.isTransformationConnected(transformation);
      if (isTransformationConnected) {
        return this.transformations.splice($.inArray(isTransformationConnected), 1);
      }
    };

    /*
      Redraws the attached transformations (e.g. after the window was moved)
    */


    Engine.prototype.redrawAttachedTransformationLines = function() {
      var storedTransformation, _i, _len, _ref, _results;
      _ref = this.transformations;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        storedTransformation = _ref[_i];
        _results.push(storedTransformation.object.redraw());
      }
      return _results;
    };

    /*
      Checks if this engine has a transformation for which it is the IN-ENGINE
    
      return true if this engine is an IN-ENGINE
    */


    Engine.prototype.isInEngine = function() {
      var storedTransformation, _i, _len, _ref;
      _ref = this.transformations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        storedTransformation = _ref[_i];
        if (storedTransformation.isInEngine) {
          return true;
        }
      }
      return false;
    };

    /*
      Checks if this engine has a transformation for which it is the OUT-ENGINE
    
      return true if this engine is an OUT-ENGINE
    */


    Engine.prototype.isOutEngine = function() {
      var storedTransformation, _i, _len, _ref;
      _ref = this.transformations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        storedTransformation = _ref[_i];
        if (!storedTransformation.isInEngine) {
          return true;
        }
      }
      return false;
    };

    /*
      Checks if this engine is connected to another engine via 1 transformation-step
    
      return true if the engines are connected via 1 step
    */


    Engine.prototype.isConnectedTo = function(engine) {
      var storedTransformation, transformation, _i, _len, _ref;
      _ref = this.transformations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        storedTransformation = _ref[_i];
        transformation = storedTransformation.object;
        if (transformation.engineIn === engine || transformation.engineOut === engine) {
          return true;
        }
      }
      return false;
    };

    /*
      Event is triggered when the left connector is clicked
    */


    Engine.prototype.eventLeftConnectorClicked = function() {
      try {
        return EngineWindow.createNewTransformation({
          isRightConnector: false,
          connector: this.nodeLeftConnector,
          engine: this
        });
      } catch (_error) {}
    };

    /*
      Event is triggered when the left connector is clicked
    */


    Engine.prototype.eventRightConnectorClicked = function() {
      try {
        return EngineWindow.createNewTransformation({
          isRightConnector: true,
          connector: this.nodeRightConnector,
          engine: this
        });
      } catch (_error) {}
    };

    /*
      Gets all transformations without additional information (like for exmaple isInEngine)
    */


    Engine.prototype.getTransformations = function() {
      var storedTransformation;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this.transformations;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          storedTransformation = _ref[_i];
          _results.push(storedTransformation.object);
        }
        return _results;
      }).call(this);
    };

    /*
      Updates all attached transformations. Call this function if the engine-instance was updated.
    */


    Engine.prototype.updateAttachedTransformations = function() {
      var transformation, _i, _len, _ref, _ref1, _results;
      _ref = this.getTransformations();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        transformation = _ref[_i];
        _results.push((_ref1 = transformation.window) != null ? _ref1.eventEngineChanged() : void 0);
      }
      return _results;
    };

    /*
      Gets the arguments for the engine-instance
    
      return key-values
    */


    Engine.prototype.getArguments = function() {
      var argument, nodeInput, returnObject, _ref;
      returnObject = {};
      _ref = this.options.content.engineSpecificArguments;
      for (argument in _ref) {
        nodeInput = _ref[argument];
        if (nodeInput.prop("type") === "text") {
          if (nodeInput.val().length > 0) {
            returnObject[argument] = nodeInput.val();
          }
        } else if (nodeInput.prop("type") === "checkbox") {
          if (!nodeInput.prop("indeterminate")) {
            returnObject[argument] = nodeInput.prop("checked");
          }
        }
      }
      return returnObject;
    };

    /*
      Sets the given value for the given argument
    
      param key
      param value
      return true if the argument was set, false otherwise
    */


    Engine.prototype.setArgument = function(key, value) {
      var argument, nodeInput, _ref;
      _ref = this.options.content.engineSpecificArguments;
      for (argument in _ref) {
        nodeInput = _ref[argument];
        if (argument === key) {
          if (nodeInput.prop("type") === "text") {
            nodeInput.val(value);
          } else if (nodeInput.prop("type") === "checkbox") {
            this.engineSpecificArguments[argument].prop("indeterminate", false);
            if (typeof value === 'boolean') {
              nodeInput.prop("checked", value);
            } else {
              nodeInput.prop("checked", value.toLowerCase() === 'true');
            }
          }
          return true;
        }
      }
      return false;
    };

    /*
      Checks if all required arguments are set
    
      return true if this is the case, false otherwise
    */


    Engine.prototype.areRequiredArgumentsSet = function() {
      var argument, nodeInput, _ref;
      _ref = this.options.content.engineSpecificArguments;
      for (argument in _ref) {
        nodeInput = _ref[argument];
        if (this.type.isArgumentRequired(argument) && nodeInput.val().length === 0) {
          return false;
        }
      }
      return true;
    };

    /*
      Generates the line with the engine-parameters
    
      return the line or false if not all necessary informations where available
    */


    Engine.prototype.generateEngineLine = function() {
      var argument, argumentsArray, value, _ref, _ref1;
      if (this.type == null) {
        return false;
      }
      argumentsArray = [];
      _ref = this.getArguments();
      for (argument in _ref) {
        value = _ref[argument];
        argumentsArray.push("" + argument + " <- '" + value + "'");
      }
      return "" + ((_ref1 = this.type) != null ? _ref1.typeName : void 0) + "(" + (argumentsArray.join(', ')) + ")";
    };

    /*
      Deletes the engine and takes care of the associated transformations and there stored reference
    
      Also closes the window
    */


    Engine.prototype.close = function() {
      var func, storedTransformation, _i, _j, _len, _len1, _ref, _ref1, _results;
      Engine.__super__.close.call(this);
      _ref = this.transformations.slice();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        storedTransformation = _ref[_i];
        storedTransformation.object.close();
      }
      if (this.options.callbackClosed != null) {
        _ref1 = this.options.callbackClosed;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          func = _ref1[_j];
          _results.push(func(this));
        }
        return _results;
      }
    };

    /*
      Triggered when the engine-type was changed to another one.
    */


    Engine.prototype.eventEngineTypeChanged = function() {
      Engine.__super__.eventEngineTypeChanged.call(this);
      this.redrawAttachedTransformationLines();
      return this.updateAttachedTransformations();
    };

    /*
      Triggered when an engine argument was changed
    */


    Engine.prototype.eventEngineArgumentChanged = function() {
      return this.updateAttachedTransformations();
    };

    Engine.prototype.eventDragged = function() {
      Engine.__super__.eventDragged.call(this);
      return this.redrawAttachedTransformationLines();
    };

    Engine.prototype.eventResized = function() {
      Engine.__super__.eventResized.call(this);
      return this.redrawAttachedTransformationLines();
    };

    Engine.prototype.setIsMaximized = function(newState) {
      Engine.__super__.setIsMaximized.call(this, newState);
      return this.redrawAttachedTransformationLines();
    };

    return Engine;

  })(EngineWindow);

  /*
  A transformation which is currently displayed on the dashboard (with a Line)
  
  param engineIn        # IN-ENGINE
  param engineOut       # OUT-ENGINE
  param options
    scriptBody          # The initial script body
    triggerId           # The trigger-id (used to identify the server-side trigger-transformation)
  */


  Transformation = (function(_super) {

    __extends(Transformation, _super);

    function Transformation(engineIn, engineOut, options) {
      var _this = this;
      this.engineIn = engineIn;
      this.engineOut = engineOut;
      this.options = options != null ? options : {};
      this.id = Main.randomId();
      if (!this.isValidConnection()) {
        throw "Invalid transformation";
      }
      Transformation.__super__.constructor.call(this, this.options);
      this.redraw();
      if (this.options.scriptBody != null) {
        this.setScriptBody(this.options.scriptBody);
      }
      this.engineIn.registerTransformation(this, true);
      this.engineOut.registerTransformation(this, false);
      this.nodeLine.click(function() {
        return _this.eventFocusGained();
      });
      if (this.options.triggerId != null) {
        this.setTriggerTransformationId(this.options.triggerId);
      }
    }

    /*
      Serializes this transformation-object
    
      return one object containing everything needed for restoring the object
    */


    Transformation.prototype.serialize = function() {
      return {
        id: this.id,
        engine_in: this.engineIn.id,
        engine_out: this.engineOut.id,
        trigger_id: this.triggerTransformationId != null ? this.triggerTransformationId : void 0,
        script_header: this.generateScriptHeader(),
        script_body: this.getScriptBody()
      };
    };

    /*
      Sets the script body (the user input)
    
      param newScriptBody
    */


    Transformation.prototype.setScriptBody = function(newScriptBody) {
      var _ref;
      if (newScriptBody == null) {
        newScriptBody = "";
      }
      if (this.window == null) {
        this.window = new TransformationWindow(this, {
          hidden: true
        });
      }
      return (_ref = this.window) != null ? _ref.options.content.setScriptBody(newScriptBody) : void 0;
    };

    /*
      Sets the trigger-transformation id
    
      param new id
    */


    Transformation.prototype.setTriggerTransformationId = function(id) {
      var _ref;
      if (this.window == null) {
        this.window = new TransformationWindow(this, {
          hidden: true
        });
      }
      this.triggerTransformationId = id;
      return (_ref = this.window) != null ? _ref.options.content.nodeButtonStart.text("Stoppen") : void 0;
    };

    /*
      Generates the lines with the engine-parameters
    
      return string with the engine lines or empty string
    */


    Transformation.prototype.generateScriptHeader = function() {
      var lineIn, lineOut;
      lineIn = "";
      if (this.engineIn.generateEngineLine()) {
        lineIn = "IN-ENGINE: " + (this.engineIn.generateEngineLine()) + ",";
      }
      lineOut = "";
      if (this.engineOut.generateEngineLine()) {
        lineOut = "OUT-ENGINE: " + (this.engineOut.generateEngineLine()) + ",";
      }
      if (lineOut === "") {
        return lineIn;
      } else {
        return "" + lineIn + "\n" + lineOut;
      }
    };

    /*
      Gets the script body (the user input)
    
      return string with the script body or empty string
    */


    Transformation.prototype.getScriptBody = function() {
      var scriptBody, _ref;
      scriptBody = "";
      if (this.window != null) {
        scriptBody = (_ref = this.window) != null ? _ref.options.content.getScriptBody() : void 0;
      }
      return scriptBody;
    };

    /*
      Generates the complete notaql-script which shall be send to the server
    */


    Transformation.prototype.getScript = function() {
      return this.generateScriptHeader() + this.getScriptBody();
    };

    /*
      Redraws the transformation line. Basically a proxy to Line.redraw() to generate
      the parameters for this function.
    */


    Transformation.prototype.redraw = function() {
      var posEnd, posStart;
      posStart = this.engineIn.nodeRightConnectionPoint.offset();
      posEnd = this.engineOut.nodeLeftConnectionPoint.offset();
      return Transformation.__super__.redraw.call(this, posStart.left, posStart.top, posEnd.left, posEnd.top);
    };

    /*
      Deletes the transformation and takes care of the associated engines and there stored reference
    
      Also removes the line from the dashboard
    */


    Transformation.prototype.close = function() {
      var _ref, _ref1, _ref2;
      if ((((_ref = this.window) != null ? _ref.options.content.automate : void 0) != null) && ((_ref1 = this.window) != null ? _ref1.options.content.automate : void 0)) {
        this.engineIn.options.content.eventSetAutomated(false);
        this.engineOut.options.content.eventSetAutomated(false);
      }
      Transformation.__super__.close.call(this);
      if ((_ref2 = this.window) != null) {
        _ref2.close();
      }
      this.engineIn.unregisterTransformation(this);
      this.engineOut.unregisterTransformation(this);
      return this.stopTriggerTransformation();
    };

    /*
      Stops the currently running trigger-based transformation
    */


    Transformation.prototype.stopTriggerTransformation = function() {
      var request, _ref,
        _this = this;
      if (this.triggerTransformationId != null) {
        if ((_ref = this.window) != null) {
          _ref.options.content.nodeButtonStart.text("Stoppe...");
        }
        request = new ServerRequest(ServerRequest.REQUEST_TYPE_KILL, {
          id: this.triggerTransformationId
        });
        return request.addDoneFunction(function(returnJson) {
          return _this.eventTriggerTransformationStopped(returnJson);
        });
      }
    };

    /*
      Triggered when a new trigger-based transformation was started
    
      param returnJson the json-data returned by the server
    */


    Transformation.prototype.eventTriggerTransformationStarted = function(returnJson) {
      var _ref;
      this.triggerTransformationId = returnJson.trigger_id;
      this.storeServerSide("trigger_" + this.triggerTransformationId);
      if ((_ref = this.window) != null) {
        _ref.options.content.nodeButtonStart.text("Stoppen");
      }
      return Main.console.print("Trigger-Transformation gestartet (ID: " + this.triggerTransformationId + ")");
    };

    /*
      Triggered when the trigger-based transformation was stopped
    
      param returnJson the json-data returned by the server
    */


    Transformation.prototype.eventTriggerTransformationStopped = function(returnJson) {
      var _ref;
      if (returnJson.response === "error") {
        return Main.console.error(returnJson.error_message);
      } else if (returnJson.response === "ok") {
        Main.console.print("Trigger-Transformation gestoppt (ID: " + this.triggerTransformationId + ")");
        this.removeServerSide("trigger_" + this.triggerTransformationId);
        return (_ref = this.window) != null ? _ref.options.content.clearExecution() : void 0;
      }
    };

    /*
      Event is triggered when the transformation gains focus. For example because it is clicked.
    */


    Transformation.prototype.eventFocusGained = function() {
      return this.showWindow();
    };

    /*
      Event is triggered when the transformation looses focus. For example because another transformation is clicked.
    */


    Transformation.prototype.eventFocusLost = function() {};

    /*
      Checks if the transformation is valid at creation-time (e.g. different in and out engines)
    
      return true if it is valid, false otherwise
    */


    Transformation.prototype.isValidConnection = function() {
      if (this.engineIn === this.engineOut) {
        Main.console.error("Engines muessen unterschiedlich sein");
        return false;
      }
      if (this.engineIn.isInEngine() || this.engineOut.isOutEngine()) {
        Main.console.error("Beide Engines muessen einen freien Connector haben");
        return false;
      }
      if (this.engineIn.isConnectedTo(this.engineOut)) {
        Main.console.error("Es darf kein Zyklus entstehen");
        return false;
      }
      return true;
    };

    /*
      Checks if the transformation is valid at execution-time (e.g. in-engine and out-engine as specified)
    
      return true if it is valid, false otherwise
    */


    Transformation.prototype.isValidExecution = function() {
      if (!(this.engineIn.type != null) || !(this.engineOut.type != null)) {
        Main.console.error("Engine-Typ muss auf beiden Seiten spezifiziert sein");
        return false;
      }
      if (!this.engineIn.areRequiredArgumentsSet() || !this.engineOut.areRequiredArgumentsSet()) {
        Main.console.error("Bei beiden Engines muessen alle Pflichtfelder (Felder mit *) ausgefuellt sein");
        return false;
      } else {
        return true;
      }
    };

    /*
      Shows the window which belongs to this transformation
    */


    Transformation.prototype.showWindow = function() {
      if (this.window != null) {
        return this.window.setIsDisplayed(true);
      } else {
        return this.window = new TransformationWindow(this);
      }
    };

    /*
      Stores the transformation
    
      param key the key used for the key-value store for the transformations
    */


    Transformation.prototype.storeServerSide = function(key) {
      var request, serializedData, serializedDataStringBase64, serializedDataStringJson;
      serializedData = [this.engineIn.serialize(), this.engineOut.serialize()];
      serializedDataStringJson = JSON.stringify(serializedData);
      serializedDataStringBase64 = StoreWindow.encodeToBase64(serializedDataStringJson);
      return request = new ServerRequest(ServerRequest.REQUEST_TYPE_TRANSFORMATION_STORE, {
        key: key,
        transformation_base64: serializedDataStringBase64
      });
    };

    /*
      Removes the transformation from the server-side storage
    
      param key the key used for the key-value store for the transformations
    */


    Transformation.prototype.removeServerSide = function(key) {
      var request;
      return request = new ServerRequest(ServerRequest.REQUEST_TYPE_TRANSFORMATION_STORE, {
        key: key
      });
    };

    return Transformation;

  })(Line);

  /*
  A proxy to a console which displays messages
  
  param options =
    isHavingWindow                # Whether the console should also have a window on the dashboard.
    isLoggingToBrowserConsole     # Whether the console should also log to the browser-console (e.g. Firebug)
    title                         # Name of the window (displayed in the titlebar)
    windowAutoscroll              # Whether the window should automatically scroll down after appending text to it
    isShowingDebugMessages        # If debug-messages shall be displayed
    isShowingWarningsWithAltert   # If warning-messages shall be displayed with alert()
  */


  Console = (function() {

    Console.DEFAULT_IS_HAVING_CONSOLE_WINDOW = true;

    Console.DEFAULT_IS_LOGGING_TO_BROWSER_CONSOLE = true;

    Console.DEFAULT_IS_SHOWING_DEBUG_MESSAGES = false;

    Console.DEFAULT_IS_SHOWING_WARNINGS_WITH_ALTERT = true;

    function Console(options) {
      this.options = options != null ? options : {};
      if (this.options.isHavingWindow == null) {
        this.options.isHavingWindow = Console.DEFAULT_IS_HAVING_CONSOLE_WINDOW;
      }
      if (this.options.isLoggingToBrowserConsole == null) {
        this.options.isLoggingToBrowserConsole = Console.DEFAULT_IS_LOGGING_TO_BROWSER_CONSOLE;
      }
      if (this.options.isShowingDebugMessages == null) {
        this.options.isShowingDebugMessages = Console.DEFAULT_IS_SHOWING_DEBUG_MESSAGES;
      }
      if (this.options.isShowingWarningsWithAltert == null) {
        this.options.isShowingWarningsWithAltert = Console.DEFAULT_IS_SHOWING_WARNINGS_WITH_ALTERT;
      }
      if (!window.console) {
        this.options.isLoggingToBrowserConsole = false;
      }
      if (this.options.isHavingWindow) {
        this.window = new ConsoleWindow(this.options);
      }
    }

    /*
      Logs a text to the console
    
      param text
    */


    Console.prototype.print = function(text) {
      if (text == null) {
        text = "";
      }
      text = $.trim(text);
      if (this.options.isHavingWindow) {
        this.window.append(text);
      }
      if (this.options.isLoggingToBrowserConsole) {
        return console.log(text);
      }
    };

    /*
      Prints a debug message
    
      param text
    */


    Console.prototype.debug = function(text) {
      if (this.options.isShowingDebugMessages) {
        return this.print("[DEBUG] " + text);
      }
    };

    /*
      Prints a error message
    
      param text
    */


    Console.prototype.error = function(text) {
      this.print("[FEHLER] " + text);
      if (this.options.isShowingWarningsWithAltert) {
        return alert("Fehler: " + text);
      }
    };

    return Console;

  })();

  /*
  Main class
  
  param options =
    pollingIntervallMillis    # The Intervall between polling-attemps from the server in milliseconds or false to disable polling
  */


  Main = (function() {

    Main.console = new Console({
      isShowingDebugMessages: true
    });

    function Main(options) {
      this.options = options != null ? options : {};
      this.eventResponseKillAll = __bind(this.eventResponseKillAll, this);

      this.callbackEngineClosed = __bind(this.callbackEngineClosed, this);

      this.eventResponseGetEngines = __bind(this.eventResponseGetEngines, this);

      this.callbackLoadDashboard = __bind(this.callbackLoadDashboard, this);

      this.server = new Server();
      this.init();
      Main.console.print("Dashboard geladen");
    }

    /*
      Initializes everything
    */


    Main.prototype.init = function() {
      var serverRequestGetEngines,
        _this = this;
      serverRequestGetEngines = new ServerRequest(ServerRequest.REQUEST_TYPE_GET_ENGINES);
      serverRequestGetEngines.addDoneFunction(this.eventResponseGetEngines);
      this.loadStoredTransformationsFromServer();
      if ((this.options.pollingIntervallMillis != null) && this.options.pollingIntervallMillis) {
        this.messagePoller = new MessagePoller({
          pollingIntervallMillis: this.options.pollingIntervallMillis
        });
      }
      $("#nav a#buttonAddEngine").click(function() {
        return _this.eventButtonPressedAddEngine();
      });
      $("#nav a#buttonConfiguration").click(function() {
        return _this.eventButtonPressedConfiguration();
      });
      $("#nav a#buttonKillAll").click(function() {
        return _this.eventButtonPressedKillAll();
      });
      $("#nav a#buttonStore").click(function() {
        return _this.eventButtonPressedStore();
      });
      return $("#nav a#buttonLoad").click(function() {
        return _this.eventButtonPressedLoad();
      });
    };

    /*
      Gets the engine with the given id
    
      param id
      return Engine or null
    */


    Main.prototype.getEngine = function(id) {
      if (!((this.engines != null) || (this.engines[id] != null))) {
        return null;
      } else {
        return this.engines[id];
      }
    };

    /*
      Gets the engines on the dashboard
    
      return array (never null)
    */


    Main.prototype.getEngines = function() {
      var engine, enginesArray, id, _ref;
      if (this.engines == null) {
        return [];
      } else {
        enginesArray = [];
        _ref = this.engines;
        for (id in _ref) {
          engine = _ref[id];
          enginesArray.push(engine);
        }
        return enginesArray;
      }
    };

    /*
      Gets the transformation with the given id
    
      param id
      return Transformation or null
    */


    Main.prototype.getTransformation = function(id) {
      var transformation, _i, _len, _ref;
      _ref = this.getTransformations();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        transformation = _ref[_i];
        if (transformation.id === id) {
          return transformation;
        }
      }
      return null;
    };

    /*
      Gets the transformations on the dashboard
    
      return array (never null)
    */


    Main.prototype.getTransformations = function() {
      var engine, transformation, transformations, _i, _j, _len, _len1, _ref, _ref1;
      transformations = [];
      _ref = this.getEngines();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        engine = _ref[_i];
        _ref1 = engine.getTransformations();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          transformation = _ref1[_j];
          if ($.inArray(transformation, transformations) === -1) {
            transformations.push(transformation);
          }
        }
      }
      return transformations;
    };

    /*
      Get the options to be passed to new engines
    
      return options
    */


    Main.prototype.getEngineOptions = function() {
      return {
        server: this.server,
        callbackClosed: [this.callbackEngineClosed]
      };
    };

    /*
      Registers an engine. If none is passed a new one will be created
    
      param engine The engine to register
    */


    Main.prototype.addEngine = function(engine) {
      if (engine == null) {
        engine = new Engine(this.getEngineOptions());
      }
      if (this.engines == null) {
        this.engines = {};
      }
      this.engines[engine.id] = engine;
      return engine;
    };

    /*
      Triggered when the user clicks on the button which shows the config
    */


    Main.prototype.eventButtonPressedConfiguration = function() {
      return new ConfigurationWindow();
    };

    /*
      Executed when the user clicks on the button which adds an engine
    */


    Main.prototype.eventButtonPressedAddEngine = function() {
      return this.addEngine().moveToFront();
    };

    /*
      Executed when the user clicks on the button which stores the dashboard.
    */


    Main.prototype.eventButtonPressedStore = function() {
      var serializedData, serializedDataStringBase64, serializedDataStringJson, serializedDataStringJsonPretty;
      serializedData = this.serialize();
      serializedDataStringJson = JSON.stringify(serializedData);
      serializedDataStringJsonPretty = JSON.stringify(serializedData, null, 1);
      serializedDataStringBase64 = StoreWindow.encodeToBase64(serializedDataStringJson);
      StoreWindow.setLocalStorage(serializedDataStringBase64);
      new StoreWindow(serializedDataStringBase64, serializedDataStringJsonPretty);
      return Main.console.print("Dashboard gespeichert");
    };

    /*
      Executed when the user clicks on the button which loads the dashboard.
    */


    Main.prototype.eventButtonPressedLoad = function() {
      return new LoadWindow(this.callbackLoadDashboard);
    };

    /*
      Called by the LoadWindow in order to load serialized data
    */


    Main.prototype.callbackLoadDashboard = function(callbackData) {
      this.deserialize(callbackData);
      return Main.console.print("Gespeichertes Dashboard geladen");
    };

    /*
      Loads the transformations which are stored server-side.
    */


    Main.prototype.loadStoredTransformationsFromServer = function() {
      var request,
        _this = this;
      request = new ServerRequest(ServerRequest.REQUEST_TYPE_TRANSFORMATION_LOAD);
      return request.addDoneFunction(function(returnJson) {
        return _this.eventResponseLoadStoredTransformationsFromServer(returnJson);
      });
    };

    /*
      Triggered when the server responds with stored transformations.
    
      param returnJson the json returned by the server
    */


    Main.prototype.eventResponseLoadStoredTransformationsFromServer = function(returnJson) {
      var decodedData, transformation_base64, _i, _len, _ref, _results,
        _this = this;
      if (returnJson.response === "error") {
        return Main.console.error(returnJson.error_message);
      } else if (returnJson.response === "ok") {
        if (this.hasResponseWithEngines == null) {
          setTimeout(function() {
            return _this.eventResponseLoadStoredTransformationsFromServer(returnJson);
          }, 10);
          return;
        }
        _ref = returnJson.list;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          transformation_base64 = _ref[_i];
          try {
            decodedData = LoadWindow.decodeBase64(transformation_base64);
            _results.push(this.deserialize(decodedData, true));
          } catch (error) {
            _results.push(Main.console.error("Base64-Eingabe ist fehlerhaft (" + error + ")"));
          }
        }
        return _results;
      }
    };

    /*
      Serializes the dashboard into an array
    
      return array with the engines
    */


    Main.prototype.serialize = function() {
      var engine;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this.getEngines();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          engine = _ref[_i];
          _results.push(engine.serialize());
        }
        return _results;
      }).call(this);
    };

    /*
      De-Serializes the dashboard from one object generated by Main.serialize().
    
      param serializedData all engines which shall be deserialized
      param areTriggersRunning wether the trigger-transformations shall be assumed to be already running (can only be assumed if loaded from the server-side storage)
    */


    Main.prototype.deserialize = function(serializedData, areTriggersRunning) {
      var engine, engineIn, engineOut, generatedTransformations, id, serializedEngine, serializedTransformation, serializedTransformations, transformation, _i, _j, _len, _len1, _ref;
      if (serializedData == null) {
        serializedData = [];
      }
      if (areTriggersRunning == null) {
        areTriggersRunning = false;
      }
      serializedTransformations = {};
      for (_i = 0, _len = serializedData.length; _i < _len; _i++) {
        serializedEngine = serializedData[_i];
        engine = Engine.deserialize(serializedEngine, this.getEngineOptions());
        this.addEngine(engine);
        if (serializedEngine.transformations != null) {
          _ref = serializedEngine.transformations;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            serializedTransformation = _ref[_j];
            if (serializedTransformations[serializedTransformation.id] == null) {
              serializedTransformations[serializedTransformation.id] = serializedTransformation;
            }
          }
        }
      }
      generatedTransformations = [];
      for (id in serializedTransformations) {
        serializedTransformation = serializedTransformations[id];
        engineIn = this.getEngine(serializedTransformation.engine_in);
        engineOut = this.getEngine(serializedTransformation.engine_out);
        try {
          transformation = new Transformation(engineIn, engineOut, {
            scriptBody: serializedTransformation.script_body,
            triggerId: (serializedTransformation.engine_out != null) && areTriggersRunning ? serializedTransformation.trigger_id : null
          });
          generatedTransformations.push(transformation);
        } catch (error) {
          Main.console.debug("Transformation konnte nicht geladen werden (" + error + ")");
        }
      }
      return generatedTransformations;
    };

    /*
      Triggered when the server responds with engines
    */


    Main.prototype.eventResponseGetEngines = function(returnJson) {
      var returnJsonEngine;
      if ((returnJson != null ? returnJson.response : void 0) === "ok") {
        this.server.setEngines((function() {
          var _i, _len, _ref, _results;
          _ref = returnJson.list;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            returnJsonEngine = _ref[_i];
            _results.push(ServerEngine.createFromServerJson(returnJsonEngine));
          }
          return _results;
        })());
        this.hasResponseWithEngines = true;
        return Main.console.debug("Engines: " + (JSON.stringify(this.server.getEngines())));
      } else {
        return Main.console.error("Fehler: Engines konnten nicht vom Server abgeholt werden");
      }
    };

    /*
      Called by the engine when its closed
    
      param engine
    */


    Main.prototype.callbackEngineClosed = function(engine) {
      return delete this.engines[engine.id];
    };

    /*
      Triggered when the user clicks on the button which stops everything
    */


    Main.prototype.eventButtonPressedKillAll = function() {
      var serverRequestKillAll;
      if (this.getEngines().length === 0) {
        return Main.console.error("Es gibt gar keine Transformationen die man stoppen koennte");
      } else if (confirm("Wirklich alle Transformationen abbrechen?")) {
        serverRequestKillAll = new ServerRequest(ServerRequest.REQUEST_TYPE_KILL_ALL);
        return serverRequestKillAll.addDoneFunction(this.eventResponseKillAll);
      }
    };

    /*
      Triggered when the servers responds to a kill_all request
    */


    Main.prototype.eventResponseKillAll = function(returnJson) {
      var engine, transformation, _i, _len, _ref, _results;
      if ((returnJson != null ? returnJson.response : void 0) === "ok") {
        Main.console.print("Alle Jobs angehalten");
        _ref = this.getEngines();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          engine = _ref[_i];
          _results.push((function() {
            var _j, _len1, _ref1, _ref2, _results1;
            _ref1 = engine.getTransformations();
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              transformation = _ref1[_j];
              _results1.push((_ref2 = transformation.window) != null ? _ref2.options.content.clearExecution() : void 0);
            }
            return _results1;
          })());
        }
        return _results;
      } else {
        return Main.console.error("Fehler: Jobs konnten nicht gekillt werden");
      }
    };

    /*
      Generates a random id to be used for decentral coordination
    
      The usual approach would be a uuid, However, for the current use-case
      less entropy is still more than enough. 6 alphanumeric values equal
      2176782336 possible combinations.
    
      return id
    */


    Main.randomId = function() {
      var randomString;
      randomString = function(length) {
        if (length == null) {
          length = 1;
        }
        return (Math.random() + 1).toString(36).substring(2, 2 + length);
      };
      return randomString(3) + randomString(3);
    };

    return Main;

  })();

  main = new Main({
    pollingIntervallMillis: 10000
  });

}).call(this);
