###
An engine which is currently displayed on the dashboard (in a EngineWindow)

param options =
  server            # Contains informations from the server
  engineid          # The initial @id of the engine
  typeName          # The initial type of the server (e.g. "csv")
  {arguments}       # The initial arguments of the server (e.g. "csv_path")
  [callbackClosed]  # Functions to be called on close-events.
###
class Engine extends EngineWindow
  constructor: (@options = {}) ->
    # Object variables
    @type = null
    @transformations = [] # All connected transformations

    # Initialize variables
    if @options.engineid?
      @id = @options.engineid
    else
      @id = Main.randomId()

    if @options.typeName?
      passedType = @options.server.getEngine(@options.typeName)
      unless passedType?
        Main.console.error("Server hat keine Engine mit dem uebergebenen Typ '#{@options.typeName}' bereitgestellt")
        @options.typeName = null
        @options.arguments = null
      else
        @type = passedType

    if @options.arguments
      unless @type?
        Main.console.error("Es wurden Argumente ohne einen typeName uebergeben")
        @options.arguments = null
      else
        # Check if passed arguments are valid
        areArgumentsValid = true
        for argument in @options.arguments
          if argument not in @type.arguments
            Main.console.error("Uebergebenes Argument '#{argument}' wurde vom Server fuer den Typ #{@type.typeName} nicht bereitgestellt")
            areArgumentsValid = false
          unless areArgumentsValid
            @options.arguments = null

    # Bind an event to the resize-event from the browserwindow
    $(window).resize( => @redrawAttachedTransformationLines() )

    super(@options)


  ###
  Serializes this engine-object

  return one object containing everything needed for restoring the object
  ###
  serialize: ->
    serialized = {
      id : @id
      typeName : @type?.typeName
    }

    for argument, value of @getArguments()
      unless serialized.arguments?
        serialized.arguments = {}
      serialized.arguments[argument] = value

    for transformation in @getTransformations()
      unless serialized.transformations?
        serialized.transformations = []
      serialized.transformations.push(transformation.serialize())

    return serialized


  ###
  Creates an instance based on data which was previously generated by Engine.serialize()

  param serializedData
  return the new instance
  ###
  @deserialize: (serializedData, options) ->
    if serializedData.id?
      options.engineid = serializedData.id

    if serializedData.typeName?
      options.typeName = serializedData.typeName

    if serializedData.arguments?
      options.arguments = serializedData.arguments

    return new Engine(options)


  ###
  Registers a transformation to this engine.

  param transformation
  param isInEngine whether this engine is the IN-ENGINE for this transformation. if it is false it is the OUT-ENGINE
  ###
  registerTransformation: (transformation, isInEngine) ->
    @transformations.push({
      object : transformation
      isInEngine : isInEngine
    })


  ###
  Checks if the transformation is connected to this engine

  return the engine if it is, false otherwise
  ###
  isTransformationConnected: (transformation) ->
    for storedTransformation in @transformations
      if storedTransformation.object is transformation
        return storedTransformation

    return false


  ###
  Reverts a registration for a transformation to this engine.
  ###
  unregisterTransformation: (transformation) ->
    isTransformationConnected = @isTransformationConnected(transformation)
    if isTransformationConnected
      # Remove it
      @transformations.splice($.inArray(isTransformationConnected), 1)


  ###
  Redraws the attached transformations (e.g. after the window was moved)
  ###
  redrawAttachedTransformationLines: ->
    for storedTransformation in @transformations
      storedTransformation.object.redraw()


  ###
  Checks if this engine has a transformation for which it is the IN-ENGINE

  return true if this engine is an IN-ENGINE
  ###
  isInEngine: ->
    for storedTransformation in @transformations
      if storedTransformation.isInEngine
        return true

    return false


  ###
  Checks if this engine has a transformation for which it is the OUT-ENGINE

  return true if this engine is an OUT-ENGINE
  ###
  isOutEngine: ->
    for storedTransformation in @transformations
      unless storedTransformation.isInEngine
        return true

    return false


  ###
  Checks if this engine is connected to another engine via 1 transformation-step

  return true if the engines are connected via 1 step
  ###
  isConnectedTo: (engine) ->
    for storedTransformation in @transformations
      transformation = storedTransformation.object
      if transformation.engineIn is engine or transformation.engineOut is engine
        return true

    return false


  ###
  Event is triggered when the left connector is clicked
  ###
  eventLeftConnectorClicked: ->
    try EngineWindow.createNewTransformation({
      isRightConnector : false
      connector : @nodeLeftConnector
      engine : this
    })


  ###
  Event is triggered when the left connector is clicked
  ###
  eventRightConnectorClicked: ->
    try EngineWindow.createNewTransformation({
      isRightConnector : true
      connector : @nodeRightConnector
      engine : this
    })


  ###
  Gets all transformations without additional information (like for exmaple isInEngine)
  ###
  getTransformations: ->
    return (
      for storedTransformation in @transformations
        storedTransformation.object
    )


  ###
  Updates all attached transformations. Call this function if the engine-instance was updated.
  ###
  updateAttachedTransformations: ->
    for transformation in @getTransformations()
      transformation.window?.eventEngineChanged()


  ###
  Gets the arguments for the engine-instance

  return key-values
  ###
  getArguments: ->
    returnObject = {}

    for argument, nodeInput of @options.content.engineSpecificArguments
      if nodeInput.prop("type") is "text"
        if nodeInput.val().length > 0
          returnObject[argument] = nodeInput.val()
      else if nodeInput.prop("type") is "checkbox"
        # Check for null
        unless nodeInput.prop("indeterminate")
          returnObject[argument] = nodeInput.prop("checked")

    return returnObject


  ###
  Sets the given value for the given argument

  param key
  param value
  return true if the argument was set, false otherwise
  ###
  setArgument: (key, value) ->
    for argument, nodeInput of @options.content.engineSpecificArguments
      if argument is key
        if nodeInput.prop("type") is "text"
          nodeInput.val(value)
        else if nodeInput.prop("type") is "checkbox"
          @engineSpecificArguments[argument].prop("indeterminate", false)
          if typeof value  is 'boolean'
            nodeInput.prop("checked", value)
          else
            nodeInput.prop("checked", value.toLowerCase() is 'true')
        return true

    return false


  ###
  Checks if all required arguments are set

  return true if this is the case, false otherwise
  ###
  areRequiredArgumentsSet: ->
    for argument, nodeInput of @options.content.engineSpecificArguments
      if @type.isArgumentRequired(argument) and nodeInput.val().length is 0
        return false

    return true


  ###
  Generates the line with the engine-parameters

  return the line or false if not all necessary informations where available
  ###
  generateEngineLine: ->
    unless @type?
      return false

    argumentsArray = []
    for argument, value of @getArguments()
      argumentsArray.push("#{argument} <- '#{value}'")

    return "#{@type?.typeName}(#{argumentsArray.join(', ')})"


  ###
  Deletes the engine and takes care of the associated transformations and there stored reference

  Also closes the window
  ###
  close: ->
    # Close the window
    super()

    # Remove the references.
    # Using slice() on the transformations-Array to avoid concurrency errors (creates a copy by value).
    for storedTransformation in @transformations.slice()
      storedTransformation.object.close()

    if @options.callbackClosed?
      for func in @options.callbackClosed
        func(this)


  ###
  Triggered when the engine-type was changed to another one.
  ###
  eventEngineTypeChanged: ->
    super()
    @redrawAttachedTransformationLines()
    @updateAttachedTransformations()


  ###
  Triggered when an engine argument was changed
  ###
  eventEngineArgumentChanged: ->
    @updateAttachedTransformations()


  eventDragged: ->
    super()
    @redrawAttachedTransformationLines()


  eventResized: ->
    super()
    @redrawAttachedTransformationLines()


  setIsMaximized: (newState) ->
    super(newState)
    @redrawAttachedTransformationLines()
